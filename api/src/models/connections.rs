// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `connections.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MonitorDmxRequest {
    // message fields
    pub outputId: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MonitorDmxRequest {
    fn default() -> &'a MonitorDmxRequest {
        <MonitorDmxRequest as ::protobuf::Message>::default_instance()
    }
}

impl MonitorDmxRequest {
    pub fn new() -> MonitorDmxRequest {
        ::std::default::Default::default()
    }

    // string outputId = 1;


    pub fn get_outputId(&self) -> &str {
        &self.outputId
    }
    pub fn clear_outputId(&mut self) {
        self.outputId.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputId(&mut self, v: ::std::string::String) {
        self.outputId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outputId(&mut self) -> &mut ::std::string::String {
        &mut self.outputId
    }

    // Take field
    pub fn take_outputId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.outputId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MonitorDmxRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.outputId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.outputId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.outputId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.outputId.is_empty() {
            os.write_string(1, &self.outputId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonitorDmxRequest {
        MonitorDmxRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "outputId",
                |m: &MonitorDmxRequest| { &m.outputId },
                |m: &mut MonitorDmxRequest| { &mut m.outputId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MonitorDmxRequest>(
                "MonitorDmxRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MonitorDmxRequest {
        static instance: ::protobuf::rt::LazyV2<MonitorDmxRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MonitorDmxRequest::new)
    }
}

impl ::protobuf::Clear for MonitorDmxRequest {
    fn clear(&mut self) {
        self.outputId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonitorDmxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorDmxRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MonitorDmxResponse {
    // message fields
    pub universes: ::protobuf::RepeatedField<MonitorDmxUniverse>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MonitorDmxResponse {
    fn default() -> &'a MonitorDmxResponse {
        <MonitorDmxResponse as ::protobuf::Message>::default_instance()
    }
}

impl MonitorDmxResponse {
    pub fn new() -> MonitorDmxResponse {
        ::std::default::Default::default()
    }

    // repeated .mizer.MonitorDmxUniverse universes = 1;


    pub fn get_universes(&self) -> &[MonitorDmxUniverse] {
        &self.universes
    }
    pub fn clear_universes(&mut self) {
        self.universes.clear();
    }

    // Param is passed by value, moved
    pub fn set_universes(&mut self, v: ::protobuf::RepeatedField<MonitorDmxUniverse>) {
        self.universes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_universes(&mut self) -> &mut ::protobuf::RepeatedField<MonitorDmxUniverse> {
        &mut self.universes
    }

    // Take field
    pub fn take_universes(&mut self) -> ::protobuf::RepeatedField<MonitorDmxUniverse> {
        ::std::mem::replace(&mut self.universes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MonitorDmxResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.universes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.universes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.universes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.universes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonitorDmxResponse {
        MonitorDmxResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MonitorDmxUniverse>>(
                "universes",
                |m: &MonitorDmxResponse| { &m.universes },
                |m: &mut MonitorDmxResponse| { &mut m.universes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MonitorDmxResponse>(
                "MonitorDmxResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MonitorDmxResponse {
        static instance: ::protobuf::rt::LazyV2<MonitorDmxResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MonitorDmxResponse::new)
    }
}

impl ::protobuf::Clear for MonitorDmxResponse {
    fn clear(&mut self) {
        self.universes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonitorDmxResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorDmxResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MonitorDmxUniverse {
    // message fields
    pub universe: u32,
    pub channels: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MonitorDmxUniverse {
    fn default() -> &'a MonitorDmxUniverse {
        <MonitorDmxUniverse as ::protobuf::Message>::default_instance()
    }
}

impl MonitorDmxUniverse {
    pub fn new() -> MonitorDmxUniverse {
        ::std::default::Default::default()
    }

    // uint32 universe = 1;


    pub fn get_universe(&self) -> u32 {
        self.universe
    }
    pub fn clear_universe(&mut self) {
        self.universe = 0;
    }

    // Param is passed by value, moved
    pub fn set_universe(&mut self, v: u32) {
        self.universe = v;
    }

    // bytes channels = 2;


    pub fn get_channels(&self) -> &[u8] {
        &self.channels
    }
    pub fn clear_channels(&mut self) {
        self.channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: ::std::vec::Vec<u8>) {
        self.channels = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channels(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.channels
    }

    // Take field
    pub fn take_channels(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.channels, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MonitorDmxUniverse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.universe = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.channels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.universe != 0 {
            my_size += ::protobuf::rt::value_size(1, self.universe, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.channels.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.channels);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.universe != 0 {
            os.write_uint32(1, self.universe)?;
        }
        if !self.channels.is_empty() {
            os.write_bytes(2, &self.channels)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonitorDmxUniverse {
        MonitorDmxUniverse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "universe",
                |m: &MonitorDmxUniverse| { &m.universe },
                |m: &mut MonitorDmxUniverse| { &mut m.universe },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "channels",
                |m: &MonitorDmxUniverse| { &m.channels },
                |m: &mut MonitorDmxUniverse| { &mut m.channels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MonitorDmxUniverse>(
                "MonitorDmxUniverse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MonitorDmxUniverse {
        static instance: ::protobuf::rt::LazyV2<MonitorDmxUniverse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MonitorDmxUniverse::new)
    }
}

impl ::protobuf::Clear for MonitorDmxUniverse {
    fn clear(&mut self) {
        self.universe = 0;
        self.channels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonitorDmxUniverse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorDmxUniverse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetConnectionsRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetConnectionsRequest {
    fn default() -> &'a GetConnectionsRequest {
        <GetConnectionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConnectionsRequest {
    pub fn new() -> GetConnectionsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetConnectionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetConnectionsRequest {
        GetConnectionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetConnectionsRequest>(
                "GetConnectionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetConnectionsRequest {
        static instance: ::protobuf::rt::LazyV2<GetConnectionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetConnectionsRequest::new)
    }
}

impl ::protobuf::Clear for GetConnectionsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetConnectionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConnectionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AddArtnetRequest {
    // message fields
    pub name: ::std::string::String,
    pub host: ::std::string::String,
    pub port: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddArtnetRequest {
    fn default() -> &'a AddArtnetRequest {
        <AddArtnetRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddArtnetRequest {
    pub fn new() -> AddArtnetRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string host = 2;


    pub fn get_host(&self) -> &str {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }

    // uint32 port = 3;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }
}

impl ::protobuf::Message for AddArtnetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(3, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.host.is_empty() {
            os.write_string(2, &self.host)?;
        }
        if self.port != 0 {
            os.write_uint32(3, self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddArtnetRequest {
        AddArtnetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AddArtnetRequest| { &m.name },
                |m: &mut AddArtnetRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host",
                |m: &AddArtnetRequest| { &m.host },
                |m: &mut AddArtnetRequest| { &mut m.host },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port",
                |m: &AddArtnetRequest| { &m.port },
                |m: &mut AddArtnetRequest| { &mut m.port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddArtnetRequest>(
                "AddArtnetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddArtnetRequest {
        static instance: ::protobuf::rt::LazyV2<AddArtnetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddArtnetRequest::new)
    }
}

impl ::protobuf::Clear for AddArtnetRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.host.clear();
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddArtnetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddArtnetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AddSacnRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddSacnRequest {
    fn default() -> &'a AddSacnRequest {
        <AddSacnRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddSacnRequest {
    pub fn new() -> AddSacnRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AddSacnRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddSacnRequest {
        AddSacnRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AddSacnRequest| { &m.name },
                |m: &mut AddSacnRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddSacnRequest>(
                "AddSacnRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddSacnRequest {
        static instance: ::protobuf::rt::LazyV2<AddSacnRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddSacnRequest::new)
    }
}

impl ::protobuf::Clear for AddSacnRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddSacnRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddSacnRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Connections {
    // message fields
    pub connections: ::protobuf::RepeatedField<Connection>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Connections {
    fn default() -> &'a Connections {
        <Connections as ::protobuf::Message>::default_instance()
    }
}

impl Connections {
    pub fn new() -> Connections {
        ::std::default::Default::default()
    }

    // repeated .mizer.Connection connections = 1;


    pub fn get_connections(&self) -> &[Connection] {
        &self.connections
    }
    pub fn clear_connections(&mut self) {
        self.connections.clear();
    }

    // Param is passed by value, moved
    pub fn set_connections(&mut self, v: ::protobuf::RepeatedField<Connection>) {
        self.connections = v;
    }

    // Mutable pointer to the field.
    pub fn mut_connections(&mut self) -> &mut ::protobuf::RepeatedField<Connection> {
        &mut self.connections
    }

    // Take field
    pub fn take_connections(&mut self) -> ::protobuf::RepeatedField<Connection> {
        ::std::mem::replace(&mut self.connections, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Connections {
    fn is_initialized(&self) -> bool {
        for v in &self.connections {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.connections)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.connections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.connections {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Connections {
        Connections::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Connection>>(
                "connections",
                |m: &Connections| { &m.connections },
                |m: &mut Connections| { &mut m.connections },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Connections>(
                "Connections",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Connections {
        static instance: ::protobuf::rt::LazyV2<Connections> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Connections::new)
    }
}

impl ::protobuf::Clear for Connections {
    fn clear(&mut self) {
        self.connections.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Connections {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Connections {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Connection {
    // message fields
    pub name: ::std::string::String,
    // message oneof groups
    pub connection: ::std::option::Option<Connection_oneof_connection>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Connection {
    fn default() -> &'a Connection {
        <Connection as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Connection_oneof_connection {
    dmx(DmxConnection),
    midi(MidiConnection),
    osc(OscConnection),
    proDJLink(ProDjLinkConnection),
    helios(HeliosConnection),
}

impl Connection {
    pub fn new() -> Connection {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .mizer.DmxConnection dmx = 10;


    pub fn get_dmx(&self) -> &DmxConnection {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::dmx(ref v)) => v,
            _ => <DmxConnection as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_dmx(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_dmx(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::dmx(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dmx(&mut self, v: DmxConnection) {
        self.connection = ::std::option::Option::Some(Connection_oneof_connection::dmx(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dmx(&mut self) -> &mut DmxConnection {
        if let ::std::option::Option::Some(Connection_oneof_connection::dmx(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(Connection_oneof_connection::dmx(DmxConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::dmx(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dmx(&mut self) -> DmxConnection {
        if self.has_dmx() {
            match self.connection.take() {
                ::std::option::Option::Some(Connection_oneof_connection::dmx(v)) => v,
                _ => panic!(),
            }
        } else {
            DmxConnection::new()
        }
    }

    // .mizer.MidiConnection midi = 11;


    pub fn get_midi(&self) -> &MidiConnection {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::midi(ref v)) => v,
            _ => <MidiConnection as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_midi(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_midi(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::midi(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_midi(&mut self, v: MidiConnection) {
        self.connection = ::std::option::Option::Some(Connection_oneof_connection::midi(v))
    }

    // Mutable pointer to the field.
    pub fn mut_midi(&mut self) -> &mut MidiConnection {
        if let ::std::option::Option::Some(Connection_oneof_connection::midi(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(Connection_oneof_connection::midi(MidiConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::midi(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_midi(&mut self) -> MidiConnection {
        if self.has_midi() {
            match self.connection.take() {
                ::std::option::Option::Some(Connection_oneof_connection::midi(v)) => v,
                _ => panic!(),
            }
        } else {
            MidiConnection::new()
        }
    }

    // .mizer.OscConnection osc = 12;


    pub fn get_osc(&self) -> &OscConnection {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::osc(ref v)) => v,
            _ => <OscConnection as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_osc(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_osc(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::osc(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_osc(&mut self, v: OscConnection) {
        self.connection = ::std::option::Option::Some(Connection_oneof_connection::osc(v))
    }

    // Mutable pointer to the field.
    pub fn mut_osc(&mut self) -> &mut OscConnection {
        if let ::std::option::Option::Some(Connection_oneof_connection::osc(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(Connection_oneof_connection::osc(OscConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::osc(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_osc(&mut self) -> OscConnection {
        if self.has_osc() {
            match self.connection.take() {
                ::std::option::Option::Some(Connection_oneof_connection::osc(v)) => v,
                _ => panic!(),
            }
        } else {
            OscConnection::new()
        }
    }

    // .mizer.ProDjLinkConnection proDJLink = 13;


    pub fn get_proDJLink(&self) -> &ProDjLinkConnection {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::proDJLink(ref v)) => v,
            _ => <ProDjLinkConnection as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_proDJLink(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_proDJLink(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::proDJLink(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_proDJLink(&mut self, v: ProDjLinkConnection) {
        self.connection = ::std::option::Option::Some(Connection_oneof_connection::proDJLink(v))
    }

    // Mutable pointer to the field.
    pub fn mut_proDJLink(&mut self) -> &mut ProDjLinkConnection {
        if let ::std::option::Option::Some(Connection_oneof_connection::proDJLink(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(Connection_oneof_connection::proDJLink(ProDjLinkConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::proDJLink(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_proDJLink(&mut self) -> ProDjLinkConnection {
        if self.has_proDJLink() {
            match self.connection.take() {
                ::std::option::Option::Some(Connection_oneof_connection::proDJLink(v)) => v,
                _ => panic!(),
            }
        } else {
            ProDjLinkConnection::new()
        }
    }

    // .mizer.HeliosConnection helios = 14;


    pub fn get_helios(&self) -> &HeliosConnection {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::helios(ref v)) => v,
            _ => <HeliosConnection as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_helios(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_helios(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::helios(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_helios(&mut self, v: HeliosConnection) {
        self.connection = ::std::option::Option::Some(Connection_oneof_connection::helios(v))
    }

    // Mutable pointer to the field.
    pub fn mut_helios(&mut self) -> &mut HeliosConnection {
        if let ::std::option::Option::Some(Connection_oneof_connection::helios(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(Connection_oneof_connection::helios(HeliosConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::helios(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_helios(&mut self) -> HeliosConnection {
        if self.has_helios() {
            match self.connection.take() {
                ::std::option::Option::Some(Connection_oneof_connection::helios(v)) => v,
                _ => panic!(),
            }
        } else {
            HeliosConnection::new()
        }
    }
}

impl ::protobuf::Message for Connection {
    fn is_initialized(&self) -> bool {
        if let Some(Connection_oneof_connection::dmx(ref v)) = self.connection {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Connection_oneof_connection::midi(ref v)) = self.connection {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Connection_oneof_connection::osc(ref v)) = self.connection {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Connection_oneof_connection::proDJLink(ref v)) = self.connection {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Connection_oneof_connection::helios(ref v)) = self.connection {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connection = ::std::option::Option::Some(Connection_oneof_connection::dmx(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connection = ::std::option::Option::Some(Connection_oneof_connection::midi(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connection = ::std::option::Option::Some(Connection_oneof_connection::osc(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connection = ::std::option::Option::Some(Connection_oneof_connection::proDJLink(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connection = ::std::option::Option::Some(Connection_oneof_connection::helios(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self.connection {
            match v {
                &Connection_oneof_connection::dmx(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Connection_oneof_connection::midi(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Connection_oneof_connection::osc(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Connection_oneof_connection::proDJLink(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Connection_oneof_connection::helios(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.connection {
            match v {
                &Connection_oneof_connection::dmx(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Connection_oneof_connection::midi(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Connection_oneof_connection::osc(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Connection_oneof_connection::proDJLink(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Connection_oneof_connection::helios(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Connection {
        Connection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Connection| { &m.name },
                |m: &mut Connection| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DmxConnection>(
                "dmx",
                Connection::has_dmx,
                Connection::get_dmx,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MidiConnection>(
                "midi",
                Connection::has_midi,
                Connection::get_midi,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OscConnection>(
                "osc",
                Connection::has_osc,
                Connection::get_osc,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ProDjLinkConnection>(
                "proDJLink",
                Connection::has_proDJLink,
                Connection::get_proDJLink,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HeliosConnection>(
                "helios",
                Connection::has_helios,
                Connection::get_helios,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Connection>(
                "Connection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Connection {
        static instance: ::protobuf::rt::LazyV2<Connection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Connection::new)
    }
}

impl ::protobuf::Clear for Connection {
    fn clear(&mut self) {
        self.name.clear();
        self.connection = ::std::option::Option::None;
        self.connection = ::std::option::Option::None;
        self.connection = ::std::option::Option::None;
        self.connection = ::std::option::Option::None;
        self.connection = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Connection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Connection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DmxConnection {
    // message fields
    pub outputId: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DmxConnection {
    fn default() -> &'a DmxConnection {
        <DmxConnection as ::protobuf::Message>::default_instance()
    }
}

impl DmxConnection {
    pub fn new() -> DmxConnection {
        ::std::default::Default::default()
    }

    // string outputId = 1;


    pub fn get_outputId(&self) -> &str {
        &self.outputId
    }
    pub fn clear_outputId(&mut self) {
        self.outputId.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputId(&mut self, v: ::std::string::String) {
        self.outputId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outputId(&mut self) -> &mut ::std::string::String {
        &mut self.outputId
    }

    // Take field
    pub fn take_outputId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.outputId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DmxConnection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.outputId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.outputId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.outputId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.outputId.is_empty() {
            os.write_string(1, &self.outputId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DmxConnection {
        DmxConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "outputId",
                |m: &DmxConnection| { &m.outputId },
                |m: &mut DmxConnection| { &mut m.outputId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DmxConnection>(
                "DmxConnection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DmxConnection {
        static instance: ::protobuf::rt::LazyV2<DmxConnection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DmxConnection::new)
    }
}

impl ::protobuf::Clear for DmxConnection {
    fn clear(&mut self) {
        self.outputId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DmxConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DmxConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct HeliosConnection {
    // message fields
    pub name: ::std::string::String,
    pub firmware: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeliosConnection {
    fn default() -> &'a HeliosConnection {
        <HeliosConnection as ::protobuf::Message>::default_instance()
    }
}

impl HeliosConnection {
    pub fn new() -> HeliosConnection {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string firmware = 2;


    pub fn get_firmware(&self) -> &str {
        &self.firmware
    }
    pub fn clear_firmware(&mut self) {
        self.firmware.clear();
    }

    // Param is passed by value, moved
    pub fn set_firmware(&mut self, v: ::std::string::String) {
        self.firmware = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firmware(&mut self) -> &mut ::std::string::String {
        &mut self.firmware
    }

    // Take field
    pub fn take_firmware(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.firmware, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HeliosConnection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.firmware)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.firmware.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.firmware);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.firmware.is_empty() {
            os.write_string(2, &self.firmware)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeliosConnection {
        HeliosConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &HeliosConnection| { &m.name },
                |m: &mut HeliosConnection| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "firmware",
                |m: &HeliosConnection| { &m.firmware },
                |m: &mut HeliosConnection| { &mut m.firmware },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeliosConnection>(
                "HeliosConnection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeliosConnection {
        static instance: ::protobuf::rt::LazyV2<HeliosConnection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeliosConnection::new)
    }
}

impl ::protobuf::Clear for HeliosConnection {
    fn clear(&mut self) {
        self.name.clear();
        self.firmware.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeliosConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeliosConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MidiConnection {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MidiConnection {
    fn default() -> &'a MidiConnection {
        <MidiConnection as ::protobuf::Message>::default_instance()
    }
}

impl MidiConnection {
    pub fn new() -> MidiConnection {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MidiConnection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MidiConnection {
        MidiConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MidiConnection>(
                "MidiConnection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MidiConnection {
        static instance: ::protobuf::rt::LazyV2<MidiConnection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MidiConnection::new)
    }
}

impl ::protobuf::Clear for MidiConnection {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MidiConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MidiConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct OscConnection {
    // message fields
    pub input_port: u32,
    pub output_port: u32,
    pub output_address: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OscConnection {
    fn default() -> &'a OscConnection {
        <OscConnection as ::protobuf::Message>::default_instance()
    }
}

impl OscConnection {
    pub fn new() -> OscConnection {
        ::std::default::Default::default()
    }

    // uint32 input_port = 1;


    pub fn get_input_port(&self) -> u32 {
        self.input_port
    }
    pub fn clear_input_port(&mut self) {
        self.input_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_input_port(&mut self, v: u32) {
        self.input_port = v;
    }

    // uint32 output_port = 2;


    pub fn get_output_port(&self) -> u32 {
        self.output_port
    }
    pub fn clear_output_port(&mut self) {
        self.output_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_output_port(&mut self, v: u32) {
        self.output_port = v;
    }

    // string output_address = 3;


    pub fn get_output_address(&self) -> &str {
        &self.output_address
    }
    pub fn clear_output_address(&mut self) {
        self.output_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_output_address(&mut self, v: ::std::string::String) {
        self.output_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_address(&mut self) -> &mut ::std::string::String {
        &mut self.output_address
    }

    // Take field
    pub fn take_output_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.output_address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OscConnection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.input_port = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.output_port = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.output_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.input_port != 0 {
            my_size += ::protobuf::rt::value_size(1, self.input_port, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.output_port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.output_port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.output_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.output_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.input_port != 0 {
            os.write_uint32(1, self.input_port)?;
        }
        if self.output_port != 0 {
            os.write_uint32(2, self.output_port)?;
        }
        if !self.output_address.is_empty() {
            os.write_string(3, &self.output_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OscConnection {
        OscConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "input_port",
                |m: &OscConnection| { &m.input_port },
                |m: &mut OscConnection| { &mut m.input_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "output_port",
                |m: &OscConnection| { &m.output_port },
                |m: &mut OscConnection| { &mut m.output_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "output_address",
                |m: &OscConnection| { &m.output_address },
                |m: &mut OscConnection| { &mut m.output_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OscConnection>(
                "OscConnection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OscConnection {
        static instance: ::protobuf::rt::LazyV2<OscConnection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OscConnection::new)
    }
}

impl ::protobuf::Clear for OscConnection {
    fn clear(&mut self) {
        self.input_port = 0;
        self.output_port = 0;
        self.output_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OscConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OscConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ProDjLinkConnection {
    // message fields
    pub address: ::std::string::String,
    pub model: ::std::string::String,
    pub playerNumber: u32,
    pub playback: ::protobuf::SingularPtrField<CdjPlayback>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProDjLinkConnection {
    fn default() -> &'a ProDjLinkConnection {
        <ProDjLinkConnection as ::protobuf::Message>::default_instance()
    }
}

impl ProDjLinkConnection {
    pub fn new() -> ProDjLinkConnection {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // string model = 2;


    pub fn get_model(&self) -> &str {
        &self.model
    }
    pub fn clear_model(&mut self) {
        self.model.clear();
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: ::std::string::String) {
        self.model = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut ::std::string::String {
        &mut self.model
    }

    // Take field
    pub fn take_model(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model, ::std::string::String::new())
    }

    // uint32 playerNumber = 3;


    pub fn get_playerNumber(&self) -> u32 {
        self.playerNumber
    }
    pub fn clear_playerNumber(&mut self) {
        self.playerNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_playerNumber(&mut self, v: u32) {
        self.playerNumber = v;
    }

    // .mizer.CdjPlayback playback = 5;


    pub fn get_playback(&self) -> &CdjPlayback {
        self.playback.as_ref().unwrap_or_else(|| <CdjPlayback as ::protobuf::Message>::default_instance())
    }
    pub fn clear_playback(&mut self) {
        self.playback.clear();
    }

    pub fn has_playback(&self) -> bool {
        self.playback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playback(&mut self, v: CdjPlayback) {
        self.playback = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_playback(&mut self) -> &mut CdjPlayback {
        if self.playback.is_none() {
            self.playback.set_default();
        }
        self.playback.as_mut().unwrap()
    }

    // Take field
    pub fn take_playback(&mut self) -> CdjPlayback {
        self.playback.take().unwrap_or_else(|| CdjPlayback::new())
    }
}

impl ::protobuf::Message for ProDjLinkConnection {
    fn is_initialized(&self) -> bool {
        for v in &self.playback {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.playerNumber = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.playback)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.model.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model);
        }
        if self.playerNumber != 0 {
            my_size += ::protobuf::rt::value_size(3, self.playerNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.playback.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.model.is_empty() {
            os.write_string(2, &self.model)?;
        }
        if self.playerNumber != 0 {
            os.write_uint32(3, self.playerNumber)?;
        }
        if let Some(ref v) = self.playback.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProDjLinkConnection {
        ProDjLinkConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &ProDjLinkConnection| { &m.address },
                |m: &mut ProDjLinkConnection| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model",
                |m: &ProDjLinkConnection| { &m.model },
                |m: &mut ProDjLinkConnection| { &mut m.model },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "playerNumber",
                |m: &ProDjLinkConnection| { &m.playerNumber },
                |m: &mut ProDjLinkConnection| { &mut m.playerNumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CdjPlayback>>(
                "playback",
                |m: &ProDjLinkConnection| { &m.playback },
                |m: &mut ProDjLinkConnection| { &mut m.playback },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProDjLinkConnection>(
                "ProDjLinkConnection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProDjLinkConnection {
        static instance: ::protobuf::rt::LazyV2<ProDjLinkConnection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProDjLinkConnection::new)
    }
}

impl ::protobuf::Clear for ProDjLinkConnection {
    fn clear(&mut self) {
        self.address.clear();
        self.model.clear();
        self.playerNumber = 0;
        self.playback.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProDjLinkConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProDjLinkConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CdjPlayback {
    // message fields
    pub live: bool,
    pub bpm: f64,
    pub frame: u32,
    pub playback: CdjPlayback_State,
    pub track: ::protobuf::SingularPtrField<CdjPlayback_Track>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CdjPlayback {
    fn default() -> &'a CdjPlayback {
        <CdjPlayback as ::protobuf::Message>::default_instance()
    }
}

impl CdjPlayback {
    pub fn new() -> CdjPlayback {
        ::std::default::Default::default()
    }

    // bool live = 1;


    pub fn get_live(&self) -> bool {
        self.live
    }
    pub fn clear_live(&mut self) {
        self.live = false;
    }

    // Param is passed by value, moved
    pub fn set_live(&mut self, v: bool) {
        self.live = v;
    }

    // double bpm = 2;


    pub fn get_bpm(&self) -> f64 {
        self.bpm
    }
    pub fn clear_bpm(&mut self) {
        self.bpm = 0.;
    }

    // Param is passed by value, moved
    pub fn set_bpm(&mut self, v: f64) {
        self.bpm = v;
    }

    // uint32 frame = 3;


    pub fn get_frame(&self) -> u32 {
        self.frame
    }
    pub fn clear_frame(&mut self) {
        self.frame = 0;
    }

    // Param is passed by value, moved
    pub fn set_frame(&mut self, v: u32) {
        self.frame = v;
    }

    // .mizer.CdjPlayback.State playback = 4;


    pub fn get_playback(&self) -> CdjPlayback_State {
        self.playback
    }
    pub fn clear_playback(&mut self) {
        self.playback = CdjPlayback_State::Loading;
    }

    // Param is passed by value, moved
    pub fn set_playback(&mut self, v: CdjPlayback_State) {
        self.playback = v;
    }

    // .mizer.CdjPlayback.Track track = 5;


    pub fn get_track(&self) -> &CdjPlayback_Track {
        self.track.as_ref().unwrap_or_else(|| <CdjPlayback_Track as ::protobuf::Message>::default_instance())
    }
    pub fn clear_track(&mut self) {
        self.track.clear();
    }

    pub fn has_track(&self) -> bool {
        self.track.is_some()
    }

    // Param is passed by value, moved
    pub fn set_track(&mut self, v: CdjPlayback_Track) {
        self.track = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_track(&mut self) -> &mut CdjPlayback_Track {
        if self.track.is_none() {
            self.track.set_default();
        }
        self.track.as_mut().unwrap()
    }

    // Take field
    pub fn take_track(&mut self) -> CdjPlayback_Track {
        self.track.take().unwrap_or_else(|| CdjPlayback_Track::new())
    }
}

impl ::protobuf::Message for CdjPlayback {
    fn is_initialized(&self) -> bool {
        for v in &self.track {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.live = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.bpm = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.frame = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.playback, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.track)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.live != false {
            my_size += 2;
        }
        if self.bpm != 0. {
            my_size += 9;
        }
        if self.frame != 0 {
            my_size += ::protobuf::rt::value_size(3, self.frame, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.playback != CdjPlayback_State::Loading {
            my_size += ::protobuf::rt::enum_size(4, self.playback);
        }
        if let Some(ref v) = self.track.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.live != false {
            os.write_bool(1, self.live)?;
        }
        if self.bpm != 0. {
            os.write_double(2, self.bpm)?;
        }
        if self.frame != 0 {
            os.write_uint32(3, self.frame)?;
        }
        if self.playback != CdjPlayback_State::Loading {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.playback))?;
        }
        if let Some(ref v) = self.track.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CdjPlayback {
        CdjPlayback::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "live",
                |m: &CdjPlayback| { &m.live },
                |m: &mut CdjPlayback| { &mut m.live },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "bpm",
                |m: &CdjPlayback| { &m.bpm },
                |m: &mut CdjPlayback| { &mut m.bpm },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "frame",
                |m: &CdjPlayback| { &m.frame },
                |m: &mut CdjPlayback| { &mut m.frame },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CdjPlayback_State>>(
                "playback",
                |m: &CdjPlayback| { &m.playback },
                |m: &mut CdjPlayback| { &mut m.playback },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CdjPlayback_Track>>(
                "track",
                |m: &CdjPlayback| { &m.track },
                |m: &mut CdjPlayback| { &mut m.track },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CdjPlayback>(
                "CdjPlayback",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CdjPlayback {
        static instance: ::protobuf::rt::LazyV2<CdjPlayback> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CdjPlayback::new)
    }
}

impl ::protobuf::Clear for CdjPlayback {
    fn clear(&mut self) {
        self.live = false;
        self.bpm = 0.;
        self.frame = 0;
        self.playback = CdjPlayback_State::Loading;
        self.track.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CdjPlayback {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CdjPlayback {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CdjPlayback_Track {
    // message fields
    pub artist: ::std::string::String,
    pub title: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CdjPlayback_Track {
    fn default() -> &'a CdjPlayback_Track {
        <CdjPlayback_Track as ::protobuf::Message>::default_instance()
    }
}

impl CdjPlayback_Track {
    pub fn new() -> CdjPlayback_Track {
        ::std::default::Default::default()
    }

    // string artist = 1;


    pub fn get_artist(&self) -> &str {
        &self.artist
    }
    pub fn clear_artist(&mut self) {
        self.artist.clear();
    }

    // Param is passed by value, moved
    pub fn set_artist(&mut self, v: ::std::string::String) {
        self.artist = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_artist(&mut self) -> &mut ::std::string::String {
        &mut self.artist
    }

    // Take field
    pub fn take_artist(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.artist, ::std::string::String::new())
    }

    // string title = 2;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CdjPlayback_Track {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.artist)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.artist.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.artist);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.title);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.artist.is_empty() {
            os.write_string(1, &self.artist)?;
        }
        if !self.title.is_empty() {
            os.write_string(2, &self.title)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CdjPlayback_Track {
        CdjPlayback_Track::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "artist",
                |m: &CdjPlayback_Track| { &m.artist },
                |m: &mut CdjPlayback_Track| { &mut m.artist },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &CdjPlayback_Track| { &m.title },
                |m: &mut CdjPlayback_Track| { &mut m.title },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CdjPlayback_Track>(
                "CdjPlayback.Track",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CdjPlayback_Track {
        static instance: ::protobuf::rt::LazyV2<CdjPlayback_Track> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CdjPlayback_Track::new)
    }
}

impl ::protobuf::Clear for CdjPlayback_Track {
    fn clear(&mut self) {
        self.artist.clear();
        self.title.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CdjPlayback_Track {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CdjPlayback_Track {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum CdjPlayback_State {
    Loading = 0,
    Playing = 1,
    Cued = 2,
    Cueing = 3,
}

impl ::protobuf::ProtobufEnum for CdjPlayback_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CdjPlayback_State> {
        match value {
            0 => ::std::option::Option::Some(CdjPlayback_State::Loading),
            1 => ::std::option::Option::Some(CdjPlayback_State::Playing),
            2 => ::std::option::Option::Some(CdjPlayback_State::Cued),
            3 => ::std::option::Option::Some(CdjPlayback_State::Cueing),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CdjPlayback_State] = &[
            CdjPlayback_State::Loading,
            CdjPlayback_State::Playing,
            CdjPlayback_State::Cued,
            CdjPlayback_State::Cueing,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CdjPlayback_State>("CdjPlayback.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CdjPlayback_State {
}

impl ::std::default::Default for CdjPlayback_State {
    fn default() -> Self {
        CdjPlayback_State::Loading
    }
}

impl ::protobuf::reflect::ProtobufValue for CdjPlayback_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11connections.proto\x12\x05mizer\"/\n\x11MonitorDmxRequest\x12\x1a\n\
    \x08outputId\x18\x01\x20\x01(\tR\x08outputId\"M\n\x12MonitorDmxResponse\
    \x127\n\tuniverses\x18\x01\x20\x03(\x0b2\x19.mizer.MonitorDmxUniverseR\t\
    universes\"L\n\x12MonitorDmxUniverse\x12\x1a\n\x08universe\x18\x01\x20\
    \x01(\rR\x08universe\x12\x1a\n\x08channels\x18\x02\x20\x01(\x0cR\x08chan\
    nels\"\x17\n\x15GetConnectionsRequest\"N\n\x10AddArtnetRequest\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04host\x18\x02\x20\x01(\
    \tR\x04host\x12\x12\n\x04port\x18\x03\x20\x01(\rR\x04port\"$\n\x0eAddSac\
    nRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"B\n\x0bConnectio\
    ns\x123\n\x0bconnections\x18\x01\x20\x03(\x0b2\x11.mizer.ConnectionR\x0b\
    connections\"\x9e\x02\n\nConnection\x12\x12\n\x04name\x18\x01\x20\x01(\t\
    R\x04name\x12(\n\x03dmx\x18\n\x20\x01(\x0b2\x14.mizer.DmxConnectionH\0R\
    \x03dmx\x12+\n\x04midi\x18\x0b\x20\x01(\x0b2\x15.mizer.MidiConnectionH\0\
    R\x04midi\x12(\n\x03osc\x18\x0c\x20\x01(\x0b2\x14.mizer.OscConnectionH\0\
    R\x03osc\x12:\n\tproDJLink\x18\r\x20\x01(\x0b2\x1a.mizer.ProDjLinkConnec\
    tionH\0R\tproDJLink\x121\n\x06helios\x18\x0e\x20\x01(\x0b2\x17.mizer.Hel\
    iosConnectionH\0R\x06heliosB\x0c\n\nconnection\"+\n\rDmxConnection\x12\
    \x1a\n\x08outputId\x18\x01\x20\x01(\tR\x08outputId\"B\n\x10HeliosConnect\
    ion\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1a\n\x08firmware\
    \x18\x02\x20\x01(\tR\x08firmware\"\x10\n\x0eMidiConnection\"v\n\rOscConn\
    ection\x12\x1d\n\ninput_port\x18\x01\x20\x01(\rR\tinputPort\x12\x1f\n\
    \x0boutput_port\x18\x02\x20\x01(\rR\noutputPort\x12%\n\x0eoutput_address\
    \x18\x03\x20\x01(\tR\routputAddress\"\x99\x01\n\x13ProDjLinkConnection\
    \x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07address\x12\x14\n\x05model\
    \x18\x02\x20\x01(\tR\x05model\x12\"\n\x0cplayerNumber\x18\x03\x20\x01(\r\
    R\x0cplayerNumber\x12.\n\x08playback\x18\x05\x20\x01(\x0b2\x12.mizer.Cdj\
    PlaybackR\x08playback\"\x9f\x02\n\x0bCdjPlayback\x12\x12\n\x04live\x18\
    \x01\x20\x01(\x08R\x04live\x12\x10\n\x03bpm\x18\x02\x20\x01(\x01R\x03bpm\
    \x12\x14\n\x05frame\x18\x03\x20\x01(\rR\x05frame\x124\n\x08playback\x18\
    \x04\x20\x01(\x0e2\x18.mizer.CdjPlayback.StateR\x08playback\x12.\n\x05tr\
    ack\x18\x05\x20\x01(\x0b2\x18.mizer.CdjPlayback.TrackR\x05track\x1a5\n\
    \x05Track\x12\x16\n\x06artist\x18\x01\x20\x01(\tR\x06artist\x12\x14\n\
    \x05title\x18\x02\x20\x01(\tR\x05title\"7\n\x05State\x12\x0b\n\x07Loadin\
    g\x10\0\x12\x0b\n\x07Playing\x10\x01\x12\x08\n\x04Cued\x10\x02\x12\n\n\
    \x06Cueing\x10\x032\xa3\x02\n\x0eConnectionsApi\x12D\n\x0eGetConnections\
    \x12\x1c.mizer.GetConnectionsRequest\x1a\x12.mizer.Connections\"\0\x12C\
    \n\nMonitorDmx\x12\x18.mizer.MonitorDmxRequest\x1a\x19.mizer.MonitorDmxR\
    esponse\"\0\x12D\n\x13AddArtnetConnection\x12\x17.mizer.AddArtnetRequest\
    \x1a\x12.mizer.Connections\"\0\x12@\n\x11AddSacnConnection\x12\x15.mizer\
    .AddSacnRequest\x1a\x12.mizer.Connections\"\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
