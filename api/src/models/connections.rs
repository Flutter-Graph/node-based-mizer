// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `connections.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MonitorDmxRequest {
    // message fields
    pub outputId: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MonitorDmxRequest {
    fn default() -> &'a MonitorDmxRequest {
        <MonitorDmxRequest as ::protobuf::Message>::default_instance()
    }
}

impl MonitorDmxRequest {
    pub fn new() -> MonitorDmxRequest {
        ::std::default::Default::default()
    }

    // string outputId = 1;


    pub fn get_outputId(&self) -> &str {
        &self.outputId
    }
    pub fn clear_outputId(&mut self) {
        self.outputId.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputId(&mut self, v: ::std::string::String) {
        self.outputId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outputId(&mut self) -> &mut ::std::string::String {
        &mut self.outputId
    }

    // Take field
    pub fn take_outputId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.outputId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MonitorDmxRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.outputId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.outputId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.outputId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.outputId.is_empty() {
            os.write_string(1, &self.outputId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonitorDmxRequest {
        MonitorDmxRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "outputId",
                |m: &MonitorDmxRequest| { &m.outputId },
                |m: &mut MonitorDmxRequest| { &mut m.outputId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MonitorDmxRequest>(
                "MonitorDmxRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MonitorDmxRequest {
        static instance: ::protobuf::rt::LazyV2<MonitorDmxRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MonitorDmxRequest::new)
    }
}

impl ::protobuf::Clear for MonitorDmxRequest {
    fn clear(&mut self) {
        self.outputId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonitorDmxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorDmxRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MonitorDmxResponse {
    // message fields
    pub universes: ::protobuf::RepeatedField<MonitorDmxUniverse>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MonitorDmxResponse {
    fn default() -> &'a MonitorDmxResponse {
        <MonitorDmxResponse as ::protobuf::Message>::default_instance()
    }
}

impl MonitorDmxResponse {
    pub fn new() -> MonitorDmxResponse {
        ::std::default::Default::default()
    }

    // repeated .mizer.MonitorDmxUniverse universes = 1;


    pub fn get_universes(&self) -> &[MonitorDmxUniverse] {
        &self.universes
    }
    pub fn clear_universes(&mut self) {
        self.universes.clear();
    }

    // Param is passed by value, moved
    pub fn set_universes(&mut self, v: ::protobuf::RepeatedField<MonitorDmxUniverse>) {
        self.universes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_universes(&mut self) -> &mut ::protobuf::RepeatedField<MonitorDmxUniverse> {
        &mut self.universes
    }

    // Take field
    pub fn take_universes(&mut self) -> ::protobuf::RepeatedField<MonitorDmxUniverse> {
        ::std::mem::replace(&mut self.universes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MonitorDmxResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.universes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.universes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.universes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.universes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonitorDmxResponse {
        MonitorDmxResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MonitorDmxUniverse>>(
                "universes",
                |m: &MonitorDmxResponse| { &m.universes },
                |m: &mut MonitorDmxResponse| { &mut m.universes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MonitorDmxResponse>(
                "MonitorDmxResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MonitorDmxResponse {
        static instance: ::protobuf::rt::LazyV2<MonitorDmxResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MonitorDmxResponse::new)
    }
}

impl ::protobuf::Clear for MonitorDmxResponse {
    fn clear(&mut self) {
        self.universes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonitorDmxResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorDmxResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MonitorDmxUniverse {
    // message fields
    pub universe: u32,
    pub channels: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MonitorDmxUniverse {
    fn default() -> &'a MonitorDmxUniverse {
        <MonitorDmxUniverse as ::protobuf::Message>::default_instance()
    }
}

impl MonitorDmxUniverse {
    pub fn new() -> MonitorDmxUniverse {
        ::std::default::Default::default()
    }

    // uint32 universe = 1;


    pub fn get_universe(&self) -> u32 {
        self.universe
    }
    pub fn clear_universe(&mut self) {
        self.universe = 0;
    }

    // Param is passed by value, moved
    pub fn set_universe(&mut self, v: u32) {
        self.universe = v;
    }

    // bytes channels = 2;


    pub fn get_channels(&self) -> &[u8] {
        &self.channels
    }
    pub fn clear_channels(&mut self) {
        self.channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: ::std::vec::Vec<u8>) {
        self.channels = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channels(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.channels
    }

    // Take field
    pub fn take_channels(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.channels, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MonitorDmxUniverse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.universe = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.channels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.universe != 0 {
            my_size += ::protobuf::rt::value_size(1, self.universe, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.channels.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.channels);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.universe != 0 {
            os.write_uint32(1, self.universe)?;
        }
        if !self.channels.is_empty() {
            os.write_bytes(2, &self.channels)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonitorDmxUniverse {
        MonitorDmxUniverse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "universe",
                |m: &MonitorDmxUniverse| { &m.universe },
                |m: &mut MonitorDmxUniverse| { &mut m.universe },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "channels",
                |m: &MonitorDmxUniverse| { &m.channels },
                |m: &mut MonitorDmxUniverse| { &mut m.channels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MonitorDmxUniverse>(
                "MonitorDmxUniverse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MonitorDmxUniverse {
        static instance: ::protobuf::rt::LazyV2<MonitorDmxUniverse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MonitorDmxUniverse::new)
    }
}

impl ::protobuf::Clear for MonitorDmxUniverse {
    fn clear(&mut self) {
        self.universe = 0;
        self.channels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonitorDmxUniverse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorDmxUniverse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MonitorMidiRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MonitorMidiRequest {
    fn default() -> &'a MonitorMidiRequest {
        <MonitorMidiRequest as ::protobuf::Message>::default_instance()
    }
}

impl MonitorMidiRequest {
    pub fn new() -> MonitorMidiRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MonitorMidiRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonitorMidiRequest {
        MonitorMidiRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &MonitorMidiRequest| { &m.name },
                |m: &mut MonitorMidiRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MonitorMidiRequest>(
                "MonitorMidiRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MonitorMidiRequest {
        static instance: ::protobuf::rt::LazyV2<MonitorMidiRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MonitorMidiRequest::new)
    }
}

impl ::protobuf::Clear for MonitorMidiRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonitorMidiRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorMidiRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MonitorMidiResponse {
    // message fields
    pub timestamp: u64,
    // message oneof groups
    pub message: ::std::option::Option<MonitorMidiResponse_oneof_message>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MonitorMidiResponse {
    fn default() -> &'a MonitorMidiResponse {
        <MonitorMidiResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum MonitorMidiResponse_oneof_message {
    cc(MonitorMidiResponse_NoteMsg),
    noteOff(MonitorMidiResponse_NoteMsg),
    noteOn(MonitorMidiResponse_NoteMsg),
    sysEx(MonitorMidiResponse_SysEx),
    unknown(::std::vec::Vec<u8>),
}

impl MonitorMidiResponse {
    pub fn new() -> MonitorMidiResponse {
        ::std::default::Default::default()
    }

    // uint64 timestamp = 2;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }

    // .mizer.MonitorMidiResponse.NoteMsg cc = 3;


    pub fn get_cc(&self) -> &MonitorMidiResponse_NoteMsg {
        match self.message {
            ::std::option::Option::Some(MonitorMidiResponse_oneof_message::cc(ref v)) => v,
            _ => <MonitorMidiResponse_NoteMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_cc(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_cc(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MonitorMidiResponse_oneof_message::cc(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cc(&mut self, v: MonitorMidiResponse_NoteMsg) {
        self.message = ::std::option::Option::Some(MonitorMidiResponse_oneof_message::cc(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cc(&mut self) -> &mut MonitorMidiResponse_NoteMsg {
        if let ::std::option::Option::Some(MonitorMidiResponse_oneof_message::cc(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MonitorMidiResponse_oneof_message::cc(MonitorMidiResponse_NoteMsg::new()));
        }
        match self.message {
            ::std::option::Option::Some(MonitorMidiResponse_oneof_message::cc(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cc(&mut self) -> MonitorMidiResponse_NoteMsg {
        if self.has_cc() {
            match self.message.take() {
                ::std::option::Option::Some(MonitorMidiResponse_oneof_message::cc(v)) => v,
                _ => panic!(),
            }
        } else {
            MonitorMidiResponse_NoteMsg::new()
        }
    }

    // .mizer.MonitorMidiResponse.NoteMsg noteOff = 4;


    pub fn get_noteOff(&self) -> &MonitorMidiResponse_NoteMsg {
        match self.message {
            ::std::option::Option::Some(MonitorMidiResponse_oneof_message::noteOff(ref v)) => v,
            _ => <MonitorMidiResponse_NoteMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_noteOff(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_noteOff(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MonitorMidiResponse_oneof_message::noteOff(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_noteOff(&mut self, v: MonitorMidiResponse_NoteMsg) {
        self.message = ::std::option::Option::Some(MonitorMidiResponse_oneof_message::noteOff(v))
    }

    // Mutable pointer to the field.
    pub fn mut_noteOff(&mut self) -> &mut MonitorMidiResponse_NoteMsg {
        if let ::std::option::Option::Some(MonitorMidiResponse_oneof_message::noteOff(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MonitorMidiResponse_oneof_message::noteOff(MonitorMidiResponse_NoteMsg::new()));
        }
        match self.message {
            ::std::option::Option::Some(MonitorMidiResponse_oneof_message::noteOff(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_noteOff(&mut self) -> MonitorMidiResponse_NoteMsg {
        if self.has_noteOff() {
            match self.message.take() {
                ::std::option::Option::Some(MonitorMidiResponse_oneof_message::noteOff(v)) => v,
                _ => panic!(),
            }
        } else {
            MonitorMidiResponse_NoteMsg::new()
        }
    }

    // .mizer.MonitorMidiResponse.NoteMsg noteOn = 5;


    pub fn get_noteOn(&self) -> &MonitorMidiResponse_NoteMsg {
        match self.message {
            ::std::option::Option::Some(MonitorMidiResponse_oneof_message::noteOn(ref v)) => v,
            _ => <MonitorMidiResponse_NoteMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_noteOn(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_noteOn(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MonitorMidiResponse_oneof_message::noteOn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_noteOn(&mut self, v: MonitorMidiResponse_NoteMsg) {
        self.message = ::std::option::Option::Some(MonitorMidiResponse_oneof_message::noteOn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_noteOn(&mut self) -> &mut MonitorMidiResponse_NoteMsg {
        if let ::std::option::Option::Some(MonitorMidiResponse_oneof_message::noteOn(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MonitorMidiResponse_oneof_message::noteOn(MonitorMidiResponse_NoteMsg::new()));
        }
        match self.message {
            ::std::option::Option::Some(MonitorMidiResponse_oneof_message::noteOn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_noteOn(&mut self) -> MonitorMidiResponse_NoteMsg {
        if self.has_noteOn() {
            match self.message.take() {
                ::std::option::Option::Some(MonitorMidiResponse_oneof_message::noteOn(v)) => v,
                _ => panic!(),
            }
        } else {
            MonitorMidiResponse_NoteMsg::new()
        }
    }

    // .mizer.MonitorMidiResponse.SysEx sysEx = 6;


    pub fn get_sysEx(&self) -> &MonitorMidiResponse_SysEx {
        match self.message {
            ::std::option::Option::Some(MonitorMidiResponse_oneof_message::sysEx(ref v)) => v,
            _ => <MonitorMidiResponse_SysEx as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_sysEx(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_sysEx(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MonitorMidiResponse_oneof_message::sysEx(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sysEx(&mut self, v: MonitorMidiResponse_SysEx) {
        self.message = ::std::option::Option::Some(MonitorMidiResponse_oneof_message::sysEx(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sysEx(&mut self) -> &mut MonitorMidiResponse_SysEx {
        if let ::std::option::Option::Some(MonitorMidiResponse_oneof_message::sysEx(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MonitorMidiResponse_oneof_message::sysEx(MonitorMidiResponse_SysEx::new()));
        }
        match self.message {
            ::std::option::Option::Some(MonitorMidiResponse_oneof_message::sysEx(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sysEx(&mut self) -> MonitorMidiResponse_SysEx {
        if self.has_sysEx() {
            match self.message.take() {
                ::std::option::Option::Some(MonitorMidiResponse_oneof_message::sysEx(v)) => v,
                _ => panic!(),
            }
        } else {
            MonitorMidiResponse_SysEx::new()
        }
    }

    // bytes unknown = 7;


    pub fn get_unknown(&self) -> &[u8] {
        match self.message {
            ::std::option::Option::Some(MonitorMidiResponse_oneof_message::unknown(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_unknown(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_unknown(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MonitorMidiResponse_oneof_message::unknown(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unknown(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = ::std::option::Option::Some(MonitorMidiResponse_oneof_message::unknown(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unknown(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(MonitorMidiResponse_oneof_message::unknown(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MonitorMidiResponse_oneof_message::unknown(::std::vec::Vec::new()));
        }
        match self.message {
            ::std::option::Option::Some(MonitorMidiResponse_oneof_message::unknown(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unknown(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_unknown() {
            match self.message.take() {
                ::std::option::Option::Some(MonitorMidiResponse_oneof_message::unknown(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }
}

impl ::protobuf::Message for MonitorMidiResponse {
    fn is_initialized(&self) -> bool {
        if let Some(MonitorMidiResponse_oneof_message::cc(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MonitorMidiResponse_oneof_message::noteOff(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MonitorMidiResponse_oneof_message::noteOn(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MonitorMidiResponse_oneof_message::sysEx(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MonitorMidiResponse_oneof_message::cc(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MonitorMidiResponse_oneof_message::noteOff(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MonitorMidiResponse_oneof_message::noteOn(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MonitorMidiResponse_oneof_message::sysEx(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MonitorMidiResponse_oneof_message::unknown(is.read_bytes()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &MonitorMidiResponse_oneof_message::cc(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MonitorMidiResponse_oneof_message::noteOff(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MonitorMidiResponse_oneof_message::noteOn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MonitorMidiResponse_oneof_message::sysEx(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MonitorMidiResponse_oneof_message::unknown(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(7, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_uint64(2, self.timestamp)?;
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &MonitorMidiResponse_oneof_message::cc(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MonitorMidiResponse_oneof_message::noteOff(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MonitorMidiResponse_oneof_message::noteOn(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MonitorMidiResponse_oneof_message::sysEx(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MonitorMidiResponse_oneof_message::unknown(ref v) => {
                    os.write_bytes(7, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonitorMidiResponse {
        MonitorMidiResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &MonitorMidiResponse| { &m.timestamp },
                |m: &mut MonitorMidiResponse| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MonitorMidiResponse_NoteMsg>(
                "cc",
                MonitorMidiResponse::has_cc,
                MonitorMidiResponse::get_cc,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MonitorMidiResponse_NoteMsg>(
                "noteOff",
                MonitorMidiResponse::has_noteOff,
                MonitorMidiResponse::get_noteOff,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MonitorMidiResponse_NoteMsg>(
                "noteOn",
                MonitorMidiResponse::has_noteOn,
                MonitorMidiResponse::get_noteOn,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MonitorMidiResponse_SysEx>(
                "sysEx",
                MonitorMidiResponse::has_sysEx,
                MonitorMidiResponse::get_sysEx,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "unknown",
                MonitorMidiResponse::has_unknown,
                MonitorMidiResponse::get_unknown,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MonitorMidiResponse>(
                "MonitorMidiResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MonitorMidiResponse {
        static instance: ::protobuf::rt::LazyV2<MonitorMidiResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MonitorMidiResponse::new)
    }
}

impl ::protobuf::Clear for MonitorMidiResponse {
    fn clear(&mut self) {
        self.timestamp = 0;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonitorMidiResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorMidiResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MonitorMidiResponse_NoteMsg {
    // message fields
    pub channel: u32,
    pub note: u32,
    pub value: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MonitorMidiResponse_NoteMsg {
    fn default() -> &'a MonitorMidiResponse_NoteMsg {
        <MonitorMidiResponse_NoteMsg as ::protobuf::Message>::default_instance()
    }
}

impl MonitorMidiResponse_NoteMsg {
    pub fn new() -> MonitorMidiResponse_NoteMsg {
        ::std::default::Default::default()
    }

    // uint32 channel = 1;


    pub fn get_channel(&self) -> u32 {
        self.channel
    }
    pub fn clear_channel(&mut self) {
        self.channel = 0;
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = v;
    }

    // uint32 note = 2;


    pub fn get_note(&self) -> u32 {
        self.note
    }
    pub fn clear_note(&mut self) {
        self.note = 0;
    }

    // Param is passed by value, moved
    pub fn set_note(&mut self, v: u32) {
        self.note = v;
    }

    // uint32 value = 3;


    pub fn get_value(&self) -> u32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = v;
    }
}

impl ::protobuf::Message for MonitorMidiResponse_NoteMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.note = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.channel != 0 {
            my_size += ::protobuf::rt::value_size(1, self.channel, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.note != 0 {
            my_size += ::protobuf::rt::value_size(2, self.note, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(3, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.channel != 0 {
            os.write_uint32(1, self.channel)?;
        }
        if self.note != 0 {
            os.write_uint32(2, self.note)?;
        }
        if self.value != 0 {
            os.write_uint32(3, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonitorMidiResponse_NoteMsg {
        MonitorMidiResponse_NoteMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channel",
                |m: &MonitorMidiResponse_NoteMsg| { &m.channel },
                |m: &mut MonitorMidiResponse_NoteMsg| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "note",
                |m: &MonitorMidiResponse_NoteMsg| { &m.note },
                |m: &mut MonitorMidiResponse_NoteMsg| { &mut m.note },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "value",
                |m: &MonitorMidiResponse_NoteMsg| { &m.value },
                |m: &mut MonitorMidiResponse_NoteMsg| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MonitorMidiResponse_NoteMsg>(
                "MonitorMidiResponse.NoteMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MonitorMidiResponse_NoteMsg {
        static instance: ::protobuf::rt::LazyV2<MonitorMidiResponse_NoteMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MonitorMidiResponse_NoteMsg::new)
    }
}

impl ::protobuf::Clear for MonitorMidiResponse_NoteMsg {
    fn clear(&mut self) {
        self.channel = 0;
        self.note = 0;
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonitorMidiResponse_NoteMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorMidiResponse_NoteMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MonitorMidiResponse_SysEx {
    // message fields
    pub manufacturer1: u32,
    pub manufacturer2: u32,
    pub manufacturer3: u32,
    pub model: u32,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MonitorMidiResponse_SysEx {
    fn default() -> &'a MonitorMidiResponse_SysEx {
        <MonitorMidiResponse_SysEx as ::protobuf::Message>::default_instance()
    }
}

impl MonitorMidiResponse_SysEx {
    pub fn new() -> MonitorMidiResponse_SysEx {
        ::std::default::Default::default()
    }

    // uint32 manufacturer1 = 1;


    pub fn get_manufacturer1(&self) -> u32 {
        self.manufacturer1
    }
    pub fn clear_manufacturer1(&mut self) {
        self.manufacturer1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_manufacturer1(&mut self, v: u32) {
        self.manufacturer1 = v;
    }

    // uint32 manufacturer2 = 2;


    pub fn get_manufacturer2(&self) -> u32 {
        self.manufacturer2
    }
    pub fn clear_manufacturer2(&mut self) {
        self.manufacturer2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_manufacturer2(&mut self, v: u32) {
        self.manufacturer2 = v;
    }

    // uint32 manufacturer3 = 3;


    pub fn get_manufacturer3(&self) -> u32 {
        self.manufacturer3
    }
    pub fn clear_manufacturer3(&mut self) {
        self.manufacturer3 = 0;
    }

    // Param is passed by value, moved
    pub fn set_manufacturer3(&mut self, v: u32) {
        self.manufacturer3 = v;
    }

    // uint32 model = 4;


    pub fn get_model(&self) -> u32 {
        self.model
    }
    pub fn clear_model(&mut self) {
        self.model = 0;
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: u32) {
        self.model = v;
    }

    // bytes data = 5;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MonitorMidiResponse_SysEx {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.manufacturer1 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.manufacturer2 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.manufacturer3 = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.model = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.manufacturer1 != 0 {
            my_size += ::protobuf::rt::value_size(1, self.manufacturer1, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.manufacturer2 != 0 {
            my_size += ::protobuf::rt::value_size(2, self.manufacturer2, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.manufacturer3 != 0 {
            my_size += ::protobuf::rt::value_size(3, self.manufacturer3, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.model != 0 {
            my_size += ::protobuf::rt::value_size(4, self.model, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.manufacturer1 != 0 {
            os.write_uint32(1, self.manufacturer1)?;
        }
        if self.manufacturer2 != 0 {
            os.write_uint32(2, self.manufacturer2)?;
        }
        if self.manufacturer3 != 0 {
            os.write_uint32(3, self.manufacturer3)?;
        }
        if self.model != 0 {
            os.write_uint32(4, self.model)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(5, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonitorMidiResponse_SysEx {
        MonitorMidiResponse_SysEx::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "manufacturer1",
                |m: &MonitorMidiResponse_SysEx| { &m.manufacturer1 },
                |m: &mut MonitorMidiResponse_SysEx| { &mut m.manufacturer1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "manufacturer2",
                |m: &MonitorMidiResponse_SysEx| { &m.manufacturer2 },
                |m: &mut MonitorMidiResponse_SysEx| { &mut m.manufacturer2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "manufacturer3",
                |m: &MonitorMidiResponse_SysEx| { &m.manufacturer3 },
                |m: &mut MonitorMidiResponse_SysEx| { &mut m.manufacturer3 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "model",
                |m: &MonitorMidiResponse_SysEx| { &m.model },
                |m: &mut MonitorMidiResponse_SysEx| { &mut m.model },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &MonitorMidiResponse_SysEx| { &m.data },
                |m: &mut MonitorMidiResponse_SysEx| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MonitorMidiResponse_SysEx>(
                "MonitorMidiResponse.SysEx",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MonitorMidiResponse_SysEx {
        static instance: ::protobuf::rt::LazyV2<MonitorMidiResponse_SysEx> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MonitorMidiResponse_SysEx::new)
    }
}

impl ::protobuf::Clear for MonitorMidiResponse_SysEx {
    fn clear(&mut self) {
        self.manufacturer1 = 0;
        self.manufacturer2 = 0;
        self.manufacturer3 = 0;
        self.model = 0;
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonitorMidiResponse_SysEx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorMidiResponse_SysEx {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetConnectionsRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetConnectionsRequest {
    fn default() -> &'a GetConnectionsRequest {
        <GetConnectionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConnectionsRequest {
    pub fn new() -> GetConnectionsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetConnectionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetConnectionsRequest {
        GetConnectionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetConnectionsRequest>(
                "GetConnectionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetConnectionsRequest {
        static instance: ::protobuf::rt::LazyV2<GetConnectionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetConnectionsRequest::new)
    }
}

impl ::protobuf::Clear for GetConnectionsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetConnectionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConnectionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetDeviceProfilesRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDeviceProfilesRequest {
    fn default() -> &'a GetDeviceProfilesRequest {
        <GetDeviceProfilesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDeviceProfilesRequest {
    pub fn new() -> GetDeviceProfilesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetDeviceProfilesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDeviceProfilesRequest {
        GetDeviceProfilesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDeviceProfilesRequest>(
                "GetDeviceProfilesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetDeviceProfilesRequest {
        static instance: ::protobuf::rt::LazyV2<GetDeviceProfilesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDeviceProfilesRequest::new)
    }
}

impl ::protobuf::Clear for GetDeviceProfilesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDeviceProfilesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDeviceProfilesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ArtnetConfig {
    // message fields
    pub name: ::std::string::String,
    pub host: ::std::string::String,
    pub port: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArtnetConfig {
    fn default() -> &'a ArtnetConfig {
        <ArtnetConfig as ::protobuf::Message>::default_instance()
    }
}

impl ArtnetConfig {
    pub fn new() -> ArtnetConfig {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string host = 2;


    pub fn get_host(&self) -> &str {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }

    // uint32 port = 3;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }
}

impl ::protobuf::Message for ArtnetConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(3, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.host.is_empty() {
            os.write_string(2, &self.host)?;
        }
        if self.port != 0 {
            os.write_uint32(3, self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArtnetConfig {
        ArtnetConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ArtnetConfig| { &m.name },
                |m: &mut ArtnetConfig| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host",
                |m: &ArtnetConfig| { &m.host },
                |m: &mut ArtnetConfig| { &mut m.host },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port",
                |m: &ArtnetConfig| { &m.port },
                |m: &mut ArtnetConfig| { &mut m.port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ArtnetConfig>(
                "ArtnetConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ArtnetConfig {
        static instance: ::protobuf::rt::LazyV2<ArtnetConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ArtnetConfig::new)
    }
}

impl ::protobuf::Clear for ArtnetConfig {
    fn clear(&mut self) {
        self.name.clear();
        self.host.clear();
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArtnetConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtnetConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SacnConfig {
    // message fields
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SacnConfig {
    fn default() -> &'a SacnConfig {
        <SacnConfig as ::protobuf::Message>::default_instance()
    }
}

impl SacnConfig {
    pub fn new() -> SacnConfig {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SacnConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SacnConfig {
        SacnConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SacnConfig| { &m.name },
                |m: &mut SacnConfig| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SacnConfig>(
                "SacnConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SacnConfig {
        static instance: ::protobuf::rt::LazyV2<SacnConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SacnConfig::new)
    }
}

impl ::protobuf::Clear for SacnConfig {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SacnConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SacnConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Connections {
    // message fields
    pub connections: ::protobuf::RepeatedField<Connection>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Connections {
    fn default() -> &'a Connections {
        <Connections as ::protobuf::Message>::default_instance()
    }
}

impl Connections {
    pub fn new() -> Connections {
        ::std::default::Default::default()
    }

    // repeated .mizer.Connection connections = 1;


    pub fn get_connections(&self) -> &[Connection] {
        &self.connections
    }
    pub fn clear_connections(&mut self) {
        self.connections.clear();
    }

    // Param is passed by value, moved
    pub fn set_connections(&mut self, v: ::protobuf::RepeatedField<Connection>) {
        self.connections = v;
    }

    // Mutable pointer to the field.
    pub fn mut_connections(&mut self) -> &mut ::protobuf::RepeatedField<Connection> {
        &mut self.connections
    }

    // Take field
    pub fn take_connections(&mut self) -> ::protobuf::RepeatedField<Connection> {
        ::std::mem::replace(&mut self.connections, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Connections {
    fn is_initialized(&self) -> bool {
        for v in &self.connections {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.connections)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.connections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.connections {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Connections {
        Connections::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Connection>>(
                "connections",
                |m: &Connections| { &m.connections },
                |m: &mut Connections| { &mut m.connections },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Connections>(
                "Connections",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Connections {
        static instance: ::protobuf::rt::LazyV2<Connections> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Connections::new)
    }
}

impl ::protobuf::Clear for Connections {
    fn clear(&mut self) {
        self.connections.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Connections {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Connections {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Connection {
    // message fields
    pub name: ::std::string::String,
    // message oneof groups
    pub connection: ::std::option::Option<Connection_oneof_connection>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Connection {
    fn default() -> &'a Connection {
        <Connection as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Connection_oneof_connection {
    dmx(DmxConnection),
    midi(MidiConnection),
    osc(OscConnection),
    proDJLink(ProDjLinkConnection),
    helios(HeliosConnection),
    etherDream(EtherDreamConnection),
    gamepad(GamepadConnection),
    mqtt(MqttConnection),
}

impl Connection {
    pub fn new() -> Connection {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .mizer.DmxConnection dmx = 10;


    pub fn get_dmx(&self) -> &DmxConnection {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::dmx(ref v)) => v,
            _ => <DmxConnection as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_dmx(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_dmx(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::dmx(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dmx(&mut self, v: DmxConnection) {
        self.connection = ::std::option::Option::Some(Connection_oneof_connection::dmx(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dmx(&mut self) -> &mut DmxConnection {
        if let ::std::option::Option::Some(Connection_oneof_connection::dmx(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(Connection_oneof_connection::dmx(DmxConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::dmx(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dmx(&mut self) -> DmxConnection {
        if self.has_dmx() {
            match self.connection.take() {
                ::std::option::Option::Some(Connection_oneof_connection::dmx(v)) => v,
                _ => panic!(),
            }
        } else {
            DmxConnection::new()
        }
    }

    // .mizer.MidiConnection midi = 11;


    pub fn get_midi(&self) -> &MidiConnection {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::midi(ref v)) => v,
            _ => <MidiConnection as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_midi(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_midi(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::midi(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_midi(&mut self, v: MidiConnection) {
        self.connection = ::std::option::Option::Some(Connection_oneof_connection::midi(v))
    }

    // Mutable pointer to the field.
    pub fn mut_midi(&mut self) -> &mut MidiConnection {
        if let ::std::option::Option::Some(Connection_oneof_connection::midi(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(Connection_oneof_connection::midi(MidiConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::midi(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_midi(&mut self) -> MidiConnection {
        if self.has_midi() {
            match self.connection.take() {
                ::std::option::Option::Some(Connection_oneof_connection::midi(v)) => v,
                _ => panic!(),
            }
        } else {
            MidiConnection::new()
        }
    }

    // .mizer.OscConnection osc = 12;


    pub fn get_osc(&self) -> &OscConnection {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::osc(ref v)) => v,
            _ => <OscConnection as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_osc(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_osc(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::osc(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_osc(&mut self, v: OscConnection) {
        self.connection = ::std::option::Option::Some(Connection_oneof_connection::osc(v))
    }

    // Mutable pointer to the field.
    pub fn mut_osc(&mut self) -> &mut OscConnection {
        if let ::std::option::Option::Some(Connection_oneof_connection::osc(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(Connection_oneof_connection::osc(OscConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::osc(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_osc(&mut self) -> OscConnection {
        if self.has_osc() {
            match self.connection.take() {
                ::std::option::Option::Some(Connection_oneof_connection::osc(v)) => v,
                _ => panic!(),
            }
        } else {
            OscConnection::new()
        }
    }

    // .mizer.ProDjLinkConnection proDJLink = 13;


    pub fn get_proDJLink(&self) -> &ProDjLinkConnection {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::proDJLink(ref v)) => v,
            _ => <ProDjLinkConnection as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_proDJLink(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_proDJLink(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::proDJLink(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_proDJLink(&mut self, v: ProDjLinkConnection) {
        self.connection = ::std::option::Option::Some(Connection_oneof_connection::proDJLink(v))
    }

    // Mutable pointer to the field.
    pub fn mut_proDJLink(&mut self) -> &mut ProDjLinkConnection {
        if let ::std::option::Option::Some(Connection_oneof_connection::proDJLink(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(Connection_oneof_connection::proDJLink(ProDjLinkConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::proDJLink(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_proDJLink(&mut self) -> ProDjLinkConnection {
        if self.has_proDJLink() {
            match self.connection.take() {
                ::std::option::Option::Some(Connection_oneof_connection::proDJLink(v)) => v,
                _ => panic!(),
            }
        } else {
            ProDjLinkConnection::new()
        }
    }

    // .mizer.HeliosConnection helios = 14;


    pub fn get_helios(&self) -> &HeliosConnection {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::helios(ref v)) => v,
            _ => <HeliosConnection as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_helios(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_helios(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::helios(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_helios(&mut self, v: HeliosConnection) {
        self.connection = ::std::option::Option::Some(Connection_oneof_connection::helios(v))
    }

    // Mutable pointer to the field.
    pub fn mut_helios(&mut self) -> &mut HeliosConnection {
        if let ::std::option::Option::Some(Connection_oneof_connection::helios(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(Connection_oneof_connection::helios(HeliosConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::helios(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_helios(&mut self) -> HeliosConnection {
        if self.has_helios() {
            match self.connection.take() {
                ::std::option::Option::Some(Connection_oneof_connection::helios(v)) => v,
                _ => panic!(),
            }
        } else {
            HeliosConnection::new()
        }
    }

    // .mizer.EtherDreamConnection etherDream = 15;


    pub fn get_etherDream(&self) -> &EtherDreamConnection {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::etherDream(ref v)) => v,
            _ => <EtherDreamConnection as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_etherDream(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_etherDream(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::etherDream(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_etherDream(&mut self, v: EtherDreamConnection) {
        self.connection = ::std::option::Option::Some(Connection_oneof_connection::etherDream(v))
    }

    // Mutable pointer to the field.
    pub fn mut_etherDream(&mut self) -> &mut EtherDreamConnection {
        if let ::std::option::Option::Some(Connection_oneof_connection::etherDream(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(Connection_oneof_connection::etherDream(EtherDreamConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::etherDream(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_etherDream(&mut self) -> EtherDreamConnection {
        if self.has_etherDream() {
            match self.connection.take() {
                ::std::option::Option::Some(Connection_oneof_connection::etherDream(v)) => v,
                _ => panic!(),
            }
        } else {
            EtherDreamConnection::new()
        }
    }

    // .mizer.GamepadConnection gamepad = 16;


    pub fn get_gamepad(&self) -> &GamepadConnection {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::gamepad(ref v)) => v,
            _ => <GamepadConnection as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_gamepad(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_gamepad(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::gamepad(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gamepad(&mut self, v: GamepadConnection) {
        self.connection = ::std::option::Option::Some(Connection_oneof_connection::gamepad(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gamepad(&mut self) -> &mut GamepadConnection {
        if let ::std::option::Option::Some(Connection_oneof_connection::gamepad(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(Connection_oneof_connection::gamepad(GamepadConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::gamepad(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gamepad(&mut self) -> GamepadConnection {
        if self.has_gamepad() {
            match self.connection.take() {
                ::std::option::Option::Some(Connection_oneof_connection::gamepad(v)) => v,
                _ => panic!(),
            }
        } else {
            GamepadConnection::new()
        }
    }

    // .mizer.MqttConnection mqtt = 17;


    pub fn get_mqtt(&self) -> &MqttConnection {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::mqtt(ref v)) => v,
            _ => <MqttConnection as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_mqtt(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_mqtt(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::mqtt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mqtt(&mut self, v: MqttConnection) {
        self.connection = ::std::option::Option::Some(Connection_oneof_connection::mqtt(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mqtt(&mut self) -> &mut MqttConnection {
        if let ::std::option::Option::Some(Connection_oneof_connection::mqtt(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(Connection_oneof_connection::mqtt(MqttConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(Connection_oneof_connection::mqtt(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mqtt(&mut self) -> MqttConnection {
        if self.has_mqtt() {
            match self.connection.take() {
                ::std::option::Option::Some(Connection_oneof_connection::mqtt(v)) => v,
                _ => panic!(),
            }
        } else {
            MqttConnection::new()
        }
    }
}

impl ::protobuf::Message for Connection {
    fn is_initialized(&self) -> bool {
        if let Some(Connection_oneof_connection::dmx(ref v)) = self.connection {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Connection_oneof_connection::midi(ref v)) = self.connection {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Connection_oneof_connection::osc(ref v)) = self.connection {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Connection_oneof_connection::proDJLink(ref v)) = self.connection {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Connection_oneof_connection::helios(ref v)) = self.connection {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Connection_oneof_connection::etherDream(ref v)) = self.connection {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Connection_oneof_connection::gamepad(ref v)) = self.connection {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Connection_oneof_connection::mqtt(ref v)) = self.connection {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connection = ::std::option::Option::Some(Connection_oneof_connection::dmx(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connection = ::std::option::Option::Some(Connection_oneof_connection::midi(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connection = ::std::option::Option::Some(Connection_oneof_connection::osc(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connection = ::std::option::Option::Some(Connection_oneof_connection::proDJLink(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connection = ::std::option::Option::Some(Connection_oneof_connection::helios(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connection = ::std::option::Option::Some(Connection_oneof_connection::etherDream(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connection = ::std::option::Option::Some(Connection_oneof_connection::gamepad(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connection = ::std::option::Option::Some(Connection_oneof_connection::mqtt(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self.connection {
            match v {
                &Connection_oneof_connection::dmx(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Connection_oneof_connection::midi(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Connection_oneof_connection::osc(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Connection_oneof_connection::proDJLink(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Connection_oneof_connection::helios(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Connection_oneof_connection::etherDream(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Connection_oneof_connection::gamepad(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Connection_oneof_connection::mqtt(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.connection {
            match v {
                &Connection_oneof_connection::dmx(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Connection_oneof_connection::midi(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Connection_oneof_connection::osc(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Connection_oneof_connection::proDJLink(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Connection_oneof_connection::helios(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Connection_oneof_connection::etherDream(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Connection_oneof_connection::gamepad(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Connection_oneof_connection::mqtt(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Connection {
        Connection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Connection| { &m.name },
                |m: &mut Connection| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DmxConnection>(
                "dmx",
                Connection::has_dmx,
                Connection::get_dmx,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MidiConnection>(
                "midi",
                Connection::has_midi,
                Connection::get_midi,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OscConnection>(
                "osc",
                Connection::has_osc,
                Connection::get_osc,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ProDjLinkConnection>(
                "proDJLink",
                Connection::has_proDJLink,
                Connection::get_proDJLink,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HeliosConnection>(
                "helios",
                Connection::has_helios,
                Connection::get_helios,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EtherDreamConnection>(
                "etherDream",
                Connection::has_etherDream,
                Connection::get_etherDream,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GamepadConnection>(
                "gamepad",
                Connection::has_gamepad,
                Connection::get_gamepad,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MqttConnection>(
                "mqtt",
                Connection::has_mqtt,
                Connection::get_mqtt,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Connection>(
                "Connection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Connection {
        static instance: ::protobuf::rt::LazyV2<Connection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Connection::new)
    }
}

impl ::protobuf::Clear for Connection {
    fn clear(&mut self) {
        self.name.clear();
        self.connection = ::std::option::Option::None;
        self.connection = ::std::option::Option::None;
        self.connection = ::std::option::Option::None;
        self.connection = ::std::option::Option::None;
        self.connection = ::std::option::Option::None;
        self.connection = ::std::option::Option::None;
        self.connection = ::std::option::Option::None;
        self.connection = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Connection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Connection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DmxConnection {
    // message fields
    pub outputId: ::std::string::String,
    // message oneof groups
    pub config: ::std::option::Option<DmxConnection_oneof_config>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DmxConnection {
    fn default() -> &'a DmxConnection {
        <DmxConnection as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum DmxConnection_oneof_config {
    artnet(ArtnetConfig),
    sacn(SacnConfig),
}

impl DmxConnection {
    pub fn new() -> DmxConnection {
        ::std::default::Default::default()
    }

    // string outputId = 1;


    pub fn get_outputId(&self) -> &str {
        &self.outputId
    }
    pub fn clear_outputId(&mut self) {
        self.outputId.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputId(&mut self, v: ::std::string::String) {
        self.outputId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outputId(&mut self) -> &mut ::std::string::String {
        &mut self.outputId
    }

    // Take field
    pub fn take_outputId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.outputId, ::std::string::String::new())
    }

    // .mizer.ArtnetConfig artnet = 3;


    pub fn get_artnet(&self) -> &ArtnetConfig {
        match self.config {
            ::std::option::Option::Some(DmxConnection_oneof_config::artnet(ref v)) => v,
            _ => <ArtnetConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_artnet(&mut self) {
        self.config = ::std::option::Option::None;
    }

    pub fn has_artnet(&self) -> bool {
        match self.config {
            ::std::option::Option::Some(DmxConnection_oneof_config::artnet(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_artnet(&mut self, v: ArtnetConfig) {
        self.config = ::std::option::Option::Some(DmxConnection_oneof_config::artnet(v))
    }

    // Mutable pointer to the field.
    pub fn mut_artnet(&mut self) -> &mut ArtnetConfig {
        if let ::std::option::Option::Some(DmxConnection_oneof_config::artnet(_)) = self.config {
        } else {
            self.config = ::std::option::Option::Some(DmxConnection_oneof_config::artnet(ArtnetConfig::new()));
        }
        match self.config {
            ::std::option::Option::Some(DmxConnection_oneof_config::artnet(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_artnet(&mut self) -> ArtnetConfig {
        if self.has_artnet() {
            match self.config.take() {
                ::std::option::Option::Some(DmxConnection_oneof_config::artnet(v)) => v,
                _ => panic!(),
            }
        } else {
            ArtnetConfig::new()
        }
    }

    // .mizer.SacnConfig sacn = 4;


    pub fn get_sacn(&self) -> &SacnConfig {
        match self.config {
            ::std::option::Option::Some(DmxConnection_oneof_config::sacn(ref v)) => v,
            _ => <SacnConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_sacn(&mut self) {
        self.config = ::std::option::Option::None;
    }

    pub fn has_sacn(&self) -> bool {
        match self.config {
            ::std::option::Option::Some(DmxConnection_oneof_config::sacn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sacn(&mut self, v: SacnConfig) {
        self.config = ::std::option::Option::Some(DmxConnection_oneof_config::sacn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sacn(&mut self) -> &mut SacnConfig {
        if let ::std::option::Option::Some(DmxConnection_oneof_config::sacn(_)) = self.config {
        } else {
            self.config = ::std::option::Option::Some(DmxConnection_oneof_config::sacn(SacnConfig::new()));
        }
        match self.config {
            ::std::option::Option::Some(DmxConnection_oneof_config::sacn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sacn(&mut self) -> SacnConfig {
        if self.has_sacn() {
            match self.config.take() {
                ::std::option::Option::Some(DmxConnection_oneof_config::sacn(v)) => v,
                _ => panic!(),
            }
        } else {
            SacnConfig::new()
        }
    }
}

impl ::protobuf::Message for DmxConnection {
    fn is_initialized(&self) -> bool {
        if let Some(DmxConnection_oneof_config::artnet(ref v)) = self.config {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DmxConnection_oneof_config::sacn(ref v)) = self.config {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.outputId)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.config = ::std::option::Option::Some(DmxConnection_oneof_config::artnet(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.config = ::std::option::Option::Some(DmxConnection_oneof_config::sacn(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.outputId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.outputId);
        }
        if let ::std::option::Option::Some(ref v) = self.config {
            match v {
                &DmxConnection_oneof_config::artnet(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DmxConnection_oneof_config::sacn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.outputId.is_empty() {
            os.write_string(1, &self.outputId)?;
        }
        if let ::std::option::Option::Some(ref v) = self.config {
            match v {
                &DmxConnection_oneof_config::artnet(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DmxConnection_oneof_config::sacn(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DmxConnection {
        DmxConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "outputId",
                |m: &DmxConnection| { &m.outputId },
                |m: &mut DmxConnection| { &mut m.outputId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ArtnetConfig>(
                "artnet",
                DmxConnection::has_artnet,
                DmxConnection::get_artnet,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SacnConfig>(
                "sacn",
                DmxConnection::has_sacn,
                DmxConnection::get_sacn,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DmxConnection>(
                "DmxConnection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DmxConnection {
        static instance: ::protobuf::rt::LazyV2<DmxConnection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DmxConnection::new)
    }
}

impl ::protobuf::Clear for DmxConnection {
    fn clear(&mut self) {
        self.outputId.clear();
        self.config = ::std::option::Option::None;
        self.config = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DmxConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DmxConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct HeliosConnection {
    // message fields
    pub name: ::std::string::String,
    pub firmware: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeliosConnection {
    fn default() -> &'a HeliosConnection {
        <HeliosConnection as ::protobuf::Message>::default_instance()
    }
}

impl HeliosConnection {
    pub fn new() -> HeliosConnection {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint32 firmware = 2;


    pub fn get_firmware(&self) -> u32 {
        self.firmware
    }
    pub fn clear_firmware(&mut self) {
        self.firmware = 0;
    }

    // Param is passed by value, moved
    pub fn set_firmware(&mut self, v: u32) {
        self.firmware = v;
    }
}

impl ::protobuf::Message for HeliosConnection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.firmware = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.firmware != 0 {
            my_size += ::protobuf::rt::value_size(2, self.firmware, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.firmware != 0 {
            os.write_uint32(2, self.firmware)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeliosConnection {
        HeliosConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &HeliosConnection| { &m.name },
                |m: &mut HeliosConnection| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "firmware",
                |m: &HeliosConnection| { &m.firmware },
                |m: &mut HeliosConnection| { &mut m.firmware },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeliosConnection>(
                "HeliosConnection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeliosConnection {
        static instance: ::protobuf::rt::LazyV2<HeliosConnection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeliosConnection::new)
    }
}

impl ::protobuf::Clear for HeliosConnection {
    fn clear(&mut self) {
        self.name.clear();
        self.firmware = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeliosConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeliosConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct EtherDreamConnection {
    // message fields
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EtherDreamConnection {
    fn default() -> &'a EtherDreamConnection {
        <EtherDreamConnection as ::protobuf::Message>::default_instance()
    }
}

impl EtherDreamConnection {
    pub fn new() -> EtherDreamConnection {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EtherDreamConnection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EtherDreamConnection {
        EtherDreamConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &EtherDreamConnection| { &m.name },
                |m: &mut EtherDreamConnection| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EtherDreamConnection>(
                "EtherDreamConnection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EtherDreamConnection {
        static instance: ::protobuf::rt::LazyV2<EtherDreamConnection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EtherDreamConnection::new)
    }
}

impl ::protobuf::Clear for EtherDreamConnection {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EtherDreamConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EtherDreamConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GamepadConnection {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GamepadConnection {
    fn default() -> &'a GamepadConnection {
        <GamepadConnection as ::protobuf::Message>::default_instance()
    }
}

impl GamepadConnection {
    pub fn new() -> GamepadConnection {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GamepadConnection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GamepadConnection {
        GamepadConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &GamepadConnection| { &m.id },
                |m: &mut GamepadConnection| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GamepadConnection| { &m.name },
                |m: &mut GamepadConnection| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GamepadConnection>(
                "GamepadConnection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GamepadConnection {
        static instance: ::protobuf::rt::LazyV2<GamepadConnection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GamepadConnection::new)
    }
}

impl ::protobuf::Clear for GamepadConnection {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GamepadConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GamepadConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MidiConnection {
    // message oneof groups
    pub _device_profile: ::std::option::Option<MidiConnection_oneof__device_profile>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MidiConnection {
    fn default() -> &'a MidiConnection {
        <MidiConnection as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum MidiConnection_oneof__device_profile {
    device_profile(::std::string::String),
}

impl MidiConnection {
    pub fn new() -> MidiConnection {
        ::std::default::Default::default()
    }

    // string device_profile = 1;


    pub fn get_device_profile(&self) -> &str {
        match self._device_profile {
            ::std::option::Option::Some(MidiConnection_oneof__device_profile::device_profile(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_device_profile(&mut self) {
        self._device_profile = ::std::option::Option::None;
    }

    pub fn has_device_profile(&self) -> bool {
        match self._device_profile {
            ::std::option::Option::Some(MidiConnection_oneof__device_profile::device_profile(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_profile(&mut self, v: ::std::string::String) {
        self._device_profile = ::std::option::Option::Some(MidiConnection_oneof__device_profile::device_profile(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_profile(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(MidiConnection_oneof__device_profile::device_profile(_)) = self._device_profile {
        } else {
            self._device_profile = ::std::option::Option::Some(MidiConnection_oneof__device_profile::device_profile(::std::string::String::new()));
        }
        match self._device_profile {
            ::std::option::Option::Some(MidiConnection_oneof__device_profile::device_profile(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_profile(&mut self) -> ::std::string::String {
        if self.has_device_profile() {
            match self._device_profile.take() {
                ::std::option::Option::Some(MidiConnection_oneof__device_profile::device_profile(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for MidiConnection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._device_profile = ::std::option::Option::Some(MidiConnection_oneof__device_profile::device_profile(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self._device_profile {
            match v {
                &MidiConnection_oneof__device_profile::device_profile(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self._device_profile {
            match v {
                &MidiConnection_oneof__device_profile::device_profile(ref v) => {
                    os.write_string(1, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MidiConnection {
        MidiConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "device_profile",
                MidiConnection::has_device_profile,
                MidiConnection::get_device_profile,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MidiConnection>(
                "MidiConnection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MidiConnection {
        static instance: ::protobuf::rt::LazyV2<MidiConnection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MidiConnection::new)
    }
}

impl ::protobuf::Clear for MidiConnection {
    fn clear(&mut self) {
        self._device_profile = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MidiConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MidiConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MidiDeviceProfiles {
    // message fields
    pub profiles: ::protobuf::RepeatedField<MidiDeviceProfile>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MidiDeviceProfiles {
    fn default() -> &'a MidiDeviceProfiles {
        <MidiDeviceProfiles as ::protobuf::Message>::default_instance()
    }
}

impl MidiDeviceProfiles {
    pub fn new() -> MidiDeviceProfiles {
        ::std::default::Default::default()
    }

    // repeated .mizer.MidiDeviceProfile profiles = 1;


    pub fn get_profiles(&self) -> &[MidiDeviceProfile] {
        &self.profiles
    }
    pub fn clear_profiles(&mut self) {
        self.profiles.clear();
    }

    // Param is passed by value, moved
    pub fn set_profiles(&mut self, v: ::protobuf::RepeatedField<MidiDeviceProfile>) {
        self.profiles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_profiles(&mut self) -> &mut ::protobuf::RepeatedField<MidiDeviceProfile> {
        &mut self.profiles
    }

    // Take field
    pub fn take_profiles(&mut self) -> ::protobuf::RepeatedField<MidiDeviceProfile> {
        ::std::mem::replace(&mut self.profiles, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MidiDeviceProfiles {
    fn is_initialized(&self) -> bool {
        for v in &self.profiles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.profiles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.profiles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.profiles {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MidiDeviceProfiles {
        MidiDeviceProfiles::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MidiDeviceProfile>>(
                "profiles",
                |m: &MidiDeviceProfiles| { &m.profiles },
                |m: &mut MidiDeviceProfiles| { &mut m.profiles },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MidiDeviceProfiles>(
                "MidiDeviceProfiles",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MidiDeviceProfiles {
        static instance: ::protobuf::rt::LazyV2<MidiDeviceProfiles> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MidiDeviceProfiles::new)
    }
}

impl ::protobuf::Clear for MidiDeviceProfiles {
    fn clear(&mut self) {
        self.profiles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MidiDeviceProfiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MidiDeviceProfiles {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MidiDeviceProfile {
    // message fields
    pub id: ::std::string::String,
    pub manufacturer: ::std::string::String,
    pub model: ::std::string::String,
    pub pages: ::protobuf::RepeatedField<MidiDeviceProfile_Page>,
    // message oneof groups
    pub _layout: ::std::option::Option<MidiDeviceProfile_oneof__layout>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MidiDeviceProfile {
    fn default() -> &'a MidiDeviceProfile {
        <MidiDeviceProfile as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum MidiDeviceProfile_oneof__layout {
    layout(::std::string::String),
}

impl MidiDeviceProfile {
    pub fn new() -> MidiDeviceProfile {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string manufacturer = 2;


    pub fn get_manufacturer(&self) -> &str {
        &self.manufacturer
    }
    pub fn clear_manufacturer(&mut self) {
        self.manufacturer.clear();
    }

    // Param is passed by value, moved
    pub fn set_manufacturer(&mut self, v: ::std::string::String) {
        self.manufacturer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_manufacturer(&mut self) -> &mut ::std::string::String {
        &mut self.manufacturer
    }

    // Take field
    pub fn take_manufacturer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.manufacturer, ::std::string::String::new())
    }

    // string model = 3;


    pub fn get_model(&self) -> &str {
        &self.model
    }
    pub fn clear_model(&mut self) {
        self.model.clear();
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: ::std::string::String) {
        self.model = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut ::std::string::String {
        &mut self.model
    }

    // Take field
    pub fn take_model(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model, ::std::string::String::new())
    }

    // string layout = 4;


    pub fn get_layout(&self) -> &str {
        match self._layout {
            ::std::option::Option::Some(MidiDeviceProfile_oneof__layout::layout(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_layout(&mut self) {
        self._layout = ::std::option::Option::None;
    }

    pub fn has_layout(&self) -> bool {
        match self._layout {
            ::std::option::Option::Some(MidiDeviceProfile_oneof__layout::layout(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_layout(&mut self, v: ::std::string::String) {
        self._layout = ::std::option::Option::Some(MidiDeviceProfile_oneof__layout::layout(v))
    }

    // Mutable pointer to the field.
    pub fn mut_layout(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(MidiDeviceProfile_oneof__layout::layout(_)) = self._layout {
        } else {
            self._layout = ::std::option::Option::Some(MidiDeviceProfile_oneof__layout::layout(::std::string::String::new()));
        }
        match self._layout {
            ::std::option::Option::Some(MidiDeviceProfile_oneof__layout::layout(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_layout(&mut self) -> ::std::string::String {
        if self.has_layout() {
            match self._layout.take() {
                ::std::option::Option::Some(MidiDeviceProfile_oneof__layout::layout(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // repeated .mizer.MidiDeviceProfile.Page pages = 5;


    pub fn get_pages(&self) -> &[MidiDeviceProfile_Page] {
        &self.pages
    }
    pub fn clear_pages(&mut self) {
        self.pages.clear();
    }

    // Param is passed by value, moved
    pub fn set_pages(&mut self, v: ::protobuf::RepeatedField<MidiDeviceProfile_Page>) {
        self.pages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pages(&mut self) -> &mut ::protobuf::RepeatedField<MidiDeviceProfile_Page> {
        &mut self.pages
    }

    // Take field
    pub fn take_pages(&mut self) -> ::protobuf::RepeatedField<MidiDeviceProfile_Page> {
        ::std::mem::replace(&mut self.pages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MidiDeviceProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.pages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.manufacturer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._layout = ::std::option::Option::Some(MidiDeviceProfile_oneof__layout::layout(is.read_string()?));
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.manufacturer.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.manufacturer);
        }
        if !self.model.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model);
        }
        for value in &self.pages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self._layout {
            match v {
                &MidiDeviceProfile_oneof__layout::layout(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.manufacturer.is_empty() {
            os.write_string(2, &self.manufacturer)?;
        }
        if !self.model.is_empty() {
            os.write_string(3, &self.model)?;
        }
        for v in &self.pages {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let ::std::option::Option::Some(ref v) = self._layout {
            match v {
                &MidiDeviceProfile_oneof__layout::layout(ref v) => {
                    os.write_string(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MidiDeviceProfile {
        MidiDeviceProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &MidiDeviceProfile| { &m.id },
                |m: &mut MidiDeviceProfile| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "manufacturer",
                |m: &MidiDeviceProfile| { &m.manufacturer },
                |m: &mut MidiDeviceProfile| { &mut m.manufacturer },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model",
                |m: &MidiDeviceProfile| { &m.model },
                |m: &mut MidiDeviceProfile| { &mut m.model },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "layout",
                MidiDeviceProfile::has_layout,
                MidiDeviceProfile::get_layout,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MidiDeviceProfile_Page>>(
                "pages",
                |m: &MidiDeviceProfile| { &m.pages },
                |m: &mut MidiDeviceProfile| { &mut m.pages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MidiDeviceProfile>(
                "MidiDeviceProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MidiDeviceProfile {
        static instance: ::protobuf::rt::LazyV2<MidiDeviceProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MidiDeviceProfile::new)
    }
}

impl ::protobuf::Clear for MidiDeviceProfile {
    fn clear(&mut self) {
        self.id.clear();
        self.manufacturer.clear();
        self.model.clear();
        self._layout = ::std::option::Option::None;
        self.pages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MidiDeviceProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MidiDeviceProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MidiDeviceProfile_Page {
    // message fields
    pub name: ::std::string::String,
    pub groups: ::protobuf::RepeatedField<MidiDeviceProfile_Group>,
    pub controls: ::protobuf::RepeatedField<MidiDeviceProfile_Control>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MidiDeviceProfile_Page {
    fn default() -> &'a MidiDeviceProfile_Page {
        <MidiDeviceProfile_Page as ::protobuf::Message>::default_instance()
    }
}

impl MidiDeviceProfile_Page {
    pub fn new() -> MidiDeviceProfile_Page {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .mizer.MidiDeviceProfile.Group groups = 2;


    pub fn get_groups(&self) -> &[MidiDeviceProfile_Group] {
        &self.groups
    }
    pub fn clear_groups(&mut self) {
        self.groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_groups(&mut self, v: ::protobuf::RepeatedField<MidiDeviceProfile_Group>) {
        self.groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_groups(&mut self) -> &mut ::protobuf::RepeatedField<MidiDeviceProfile_Group> {
        &mut self.groups
    }

    // Take field
    pub fn take_groups(&mut self) -> ::protobuf::RepeatedField<MidiDeviceProfile_Group> {
        ::std::mem::replace(&mut self.groups, ::protobuf::RepeatedField::new())
    }

    // repeated .mizer.MidiDeviceProfile.Control controls = 3;


    pub fn get_controls(&self) -> &[MidiDeviceProfile_Control] {
        &self.controls
    }
    pub fn clear_controls(&mut self) {
        self.controls.clear();
    }

    // Param is passed by value, moved
    pub fn set_controls(&mut self, v: ::protobuf::RepeatedField<MidiDeviceProfile_Control>) {
        self.controls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_controls(&mut self) -> &mut ::protobuf::RepeatedField<MidiDeviceProfile_Control> {
        &mut self.controls
    }

    // Take field
    pub fn take_controls(&mut self) -> ::protobuf::RepeatedField<MidiDeviceProfile_Control> {
        ::std::mem::replace(&mut self.controls, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MidiDeviceProfile_Page {
    fn is_initialized(&self) -> bool {
        for v in &self.groups {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.controls {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.groups)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.controls)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.controls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.groups {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.controls {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MidiDeviceProfile_Page {
        MidiDeviceProfile_Page::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &MidiDeviceProfile_Page| { &m.name },
                |m: &mut MidiDeviceProfile_Page| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MidiDeviceProfile_Group>>(
                "groups",
                |m: &MidiDeviceProfile_Page| { &m.groups },
                |m: &mut MidiDeviceProfile_Page| { &mut m.groups },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MidiDeviceProfile_Control>>(
                "controls",
                |m: &MidiDeviceProfile_Page| { &m.controls },
                |m: &mut MidiDeviceProfile_Page| { &mut m.controls },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MidiDeviceProfile_Page>(
                "MidiDeviceProfile.Page",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MidiDeviceProfile_Page {
        static instance: ::protobuf::rt::LazyV2<MidiDeviceProfile_Page> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MidiDeviceProfile_Page::new)
    }
}

impl ::protobuf::Clear for MidiDeviceProfile_Page {
    fn clear(&mut self) {
        self.name.clear();
        self.groups.clear();
        self.controls.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MidiDeviceProfile_Page {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MidiDeviceProfile_Page {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MidiDeviceProfile_Group {
    // message fields
    pub name: ::std::string::String,
    pub controls: ::protobuf::RepeatedField<MidiDeviceProfile_Control>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MidiDeviceProfile_Group {
    fn default() -> &'a MidiDeviceProfile_Group {
        <MidiDeviceProfile_Group as ::protobuf::Message>::default_instance()
    }
}

impl MidiDeviceProfile_Group {
    pub fn new() -> MidiDeviceProfile_Group {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .mizer.MidiDeviceProfile.Control controls = 2;


    pub fn get_controls(&self) -> &[MidiDeviceProfile_Control] {
        &self.controls
    }
    pub fn clear_controls(&mut self) {
        self.controls.clear();
    }

    // Param is passed by value, moved
    pub fn set_controls(&mut self, v: ::protobuf::RepeatedField<MidiDeviceProfile_Control>) {
        self.controls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_controls(&mut self) -> &mut ::protobuf::RepeatedField<MidiDeviceProfile_Control> {
        &mut self.controls
    }

    // Take field
    pub fn take_controls(&mut self) -> ::protobuf::RepeatedField<MidiDeviceProfile_Control> {
        ::std::mem::replace(&mut self.controls, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MidiDeviceProfile_Group {
    fn is_initialized(&self) -> bool {
        for v in &self.controls {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.controls)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.controls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.controls {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MidiDeviceProfile_Group {
        MidiDeviceProfile_Group::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &MidiDeviceProfile_Group| { &m.name },
                |m: &mut MidiDeviceProfile_Group| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MidiDeviceProfile_Control>>(
                "controls",
                |m: &MidiDeviceProfile_Group| { &m.controls },
                |m: &mut MidiDeviceProfile_Group| { &mut m.controls },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MidiDeviceProfile_Group>(
                "MidiDeviceProfile.Group",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MidiDeviceProfile_Group {
        static instance: ::protobuf::rt::LazyV2<MidiDeviceProfile_Group> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MidiDeviceProfile_Group::new)
    }
}

impl ::protobuf::Clear for MidiDeviceProfile_Group {
    fn clear(&mut self) {
        self.name.clear();
        self.controls.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MidiDeviceProfile_Group {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MidiDeviceProfile_Group {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MidiDeviceProfile_Control {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub channel: u32,
    pub note: u32,
    pub control_type: MidiDeviceProfile_ControlType,
    pub has_output: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MidiDeviceProfile_Control {
    fn default() -> &'a MidiDeviceProfile_Control {
        <MidiDeviceProfile_Control as ::protobuf::Message>::default_instance()
    }
}

impl MidiDeviceProfile_Control {
    pub fn new() -> MidiDeviceProfile_Control {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint32 channel = 3;


    pub fn get_channel(&self) -> u32 {
        self.channel
    }
    pub fn clear_channel(&mut self) {
        self.channel = 0;
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = v;
    }

    // uint32 note = 4;


    pub fn get_note(&self) -> u32 {
        self.note
    }
    pub fn clear_note(&mut self) {
        self.note = 0;
    }

    // Param is passed by value, moved
    pub fn set_note(&mut self, v: u32) {
        self.note = v;
    }

    // .mizer.MidiDeviceProfile.ControlType control_type = 5;


    pub fn get_control_type(&self) -> MidiDeviceProfile_ControlType {
        self.control_type
    }
    pub fn clear_control_type(&mut self) {
        self.control_type = MidiDeviceProfile_ControlType::Note;
    }

    // Param is passed by value, moved
    pub fn set_control_type(&mut self, v: MidiDeviceProfile_ControlType) {
        self.control_type = v;
    }

    // bool has_output = 6;


    pub fn get_has_output(&self) -> bool {
        self.has_output
    }
    pub fn clear_has_output(&mut self) {
        self.has_output = false;
    }

    // Param is passed by value, moved
    pub fn set_has_output(&mut self, v: bool) {
        self.has_output = v;
    }
}

impl ::protobuf::Message for MidiDeviceProfile_Control {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.note = tmp;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.control_type, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_output = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.channel != 0 {
            my_size += ::protobuf::rt::value_size(3, self.channel, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.note != 0 {
            my_size += ::protobuf::rt::value_size(4, self.note, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.control_type != MidiDeviceProfile_ControlType::Note {
            my_size += ::protobuf::rt::enum_size(5, self.control_type);
        }
        if self.has_output != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.channel != 0 {
            os.write_uint32(3, self.channel)?;
        }
        if self.note != 0 {
            os.write_uint32(4, self.note)?;
        }
        if self.control_type != MidiDeviceProfile_ControlType::Note {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.control_type))?;
        }
        if self.has_output != false {
            os.write_bool(6, self.has_output)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MidiDeviceProfile_Control {
        MidiDeviceProfile_Control::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &MidiDeviceProfile_Control| { &m.id },
                |m: &mut MidiDeviceProfile_Control| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &MidiDeviceProfile_Control| { &m.name },
                |m: &mut MidiDeviceProfile_Control| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channel",
                |m: &MidiDeviceProfile_Control| { &m.channel },
                |m: &mut MidiDeviceProfile_Control| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "note",
                |m: &MidiDeviceProfile_Control| { &m.note },
                |m: &mut MidiDeviceProfile_Control| { &mut m.note },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MidiDeviceProfile_ControlType>>(
                "control_type",
                |m: &MidiDeviceProfile_Control| { &m.control_type },
                |m: &mut MidiDeviceProfile_Control| { &mut m.control_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_output",
                |m: &MidiDeviceProfile_Control| { &m.has_output },
                |m: &mut MidiDeviceProfile_Control| { &mut m.has_output },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MidiDeviceProfile_Control>(
                "MidiDeviceProfile.Control",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MidiDeviceProfile_Control {
        static instance: ::protobuf::rt::LazyV2<MidiDeviceProfile_Control> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MidiDeviceProfile_Control::new)
    }
}

impl ::protobuf::Clear for MidiDeviceProfile_Control {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.channel = 0;
        self.note = 0;
        self.control_type = MidiDeviceProfile_ControlType::Note;
        self.has_output = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MidiDeviceProfile_Control {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MidiDeviceProfile_Control {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum MidiDeviceProfile_ControlType {
    Note = 0,
    CC = 1,
}

impl ::protobuf::ProtobufEnum for MidiDeviceProfile_ControlType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MidiDeviceProfile_ControlType> {
        match value {
            0 => ::std::option::Option::Some(MidiDeviceProfile_ControlType::Note),
            1 => ::std::option::Option::Some(MidiDeviceProfile_ControlType::CC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MidiDeviceProfile_ControlType] = &[
            MidiDeviceProfile_ControlType::Note,
            MidiDeviceProfile_ControlType::CC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<MidiDeviceProfile_ControlType>("MidiDeviceProfile.ControlType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for MidiDeviceProfile_ControlType {
}

impl ::std::default::Default for MidiDeviceProfile_ControlType {
    fn default() -> Self {
        MidiDeviceProfile_ControlType::Note
    }
}

impl ::protobuf::reflect::ProtobufValue for MidiDeviceProfile_ControlType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct OscConnection {
    // message fields
    pub input_port: u32,
    pub output_port: u32,
    pub output_address: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OscConnection {
    fn default() -> &'a OscConnection {
        <OscConnection as ::protobuf::Message>::default_instance()
    }
}

impl OscConnection {
    pub fn new() -> OscConnection {
        ::std::default::Default::default()
    }

    // uint32 input_port = 1;


    pub fn get_input_port(&self) -> u32 {
        self.input_port
    }
    pub fn clear_input_port(&mut self) {
        self.input_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_input_port(&mut self, v: u32) {
        self.input_port = v;
    }

    // uint32 output_port = 2;


    pub fn get_output_port(&self) -> u32 {
        self.output_port
    }
    pub fn clear_output_port(&mut self) {
        self.output_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_output_port(&mut self, v: u32) {
        self.output_port = v;
    }

    // string output_address = 3;


    pub fn get_output_address(&self) -> &str {
        &self.output_address
    }
    pub fn clear_output_address(&mut self) {
        self.output_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_output_address(&mut self, v: ::std::string::String) {
        self.output_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_address(&mut self) -> &mut ::std::string::String {
        &mut self.output_address
    }

    // Take field
    pub fn take_output_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.output_address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OscConnection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.input_port = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.output_port = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.output_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.input_port != 0 {
            my_size += ::protobuf::rt::value_size(1, self.input_port, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.output_port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.output_port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.output_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.output_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.input_port != 0 {
            os.write_uint32(1, self.input_port)?;
        }
        if self.output_port != 0 {
            os.write_uint32(2, self.output_port)?;
        }
        if !self.output_address.is_empty() {
            os.write_string(3, &self.output_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OscConnection {
        OscConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "input_port",
                |m: &OscConnection| { &m.input_port },
                |m: &mut OscConnection| { &mut m.input_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "output_port",
                |m: &OscConnection| { &m.output_port },
                |m: &mut OscConnection| { &mut m.output_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "output_address",
                |m: &OscConnection| { &m.output_address },
                |m: &mut OscConnection| { &mut m.output_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OscConnection>(
                "OscConnection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OscConnection {
        static instance: ::protobuf::rt::LazyV2<OscConnection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OscConnection::new)
    }
}

impl ::protobuf::Clear for OscConnection {
    fn clear(&mut self) {
        self.input_port = 0;
        self.output_port = 0;
        self.output_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OscConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OscConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ProDjLinkConnection {
    // message fields
    pub address: ::std::string::String,
    pub model: ::std::string::String,
    pub playerNumber: u32,
    pub playback: ::protobuf::SingularPtrField<CdjPlayback>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProDjLinkConnection {
    fn default() -> &'a ProDjLinkConnection {
        <ProDjLinkConnection as ::protobuf::Message>::default_instance()
    }
}

impl ProDjLinkConnection {
    pub fn new() -> ProDjLinkConnection {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // string model = 2;


    pub fn get_model(&self) -> &str {
        &self.model
    }
    pub fn clear_model(&mut self) {
        self.model.clear();
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: ::std::string::String) {
        self.model = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut ::std::string::String {
        &mut self.model
    }

    // Take field
    pub fn take_model(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model, ::std::string::String::new())
    }

    // uint32 playerNumber = 3;


    pub fn get_playerNumber(&self) -> u32 {
        self.playerNumber
    }
    pub fn clear_playerNumber(&mut self) {
        self.playerNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_playerNumber(&mut self, v: u32) {
        self.playerNumber = v;
    }

    // .mizer.CdjPlayback playback = 5;


    pub fn get_playback(&self) -> &CdjPlayback {
        self.playback.as_ref().unwrap_or_else(|| <CdjPlayback as ::protobuf::Message>::default_instance())
    }
    pub fn clear_playback(&mut self) {
        self.playback.clear();
    }

    pub fn has_playback(&self) -> bool {
        self.playback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playback(&mut self, v: CdjPlayback) {
        self.playback = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_playback(&mut self) -> &mut CdjPlayback {
        if self.playback.is_none() {
            self.playback.set_default();
        }
        self.playback.as_mut().unwrap()
    }

    // Take field
    pub fn take_playback(&mut self) -> CdjPlayback {
        self.playback.take().unwrap_or_else(|| CdjPlayback::new())
    }
}

impl ::protobuf::Message for ProDjLinkConnection {
    fn is_initialized(&self) -> bool {
        for v in &self.playback {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.playerNumber = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.playback)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.model.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model);
        }
        if self.playerNumber != 0 {
            my_size += ::protobuf::rt::value_size(3, self.playerNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.playback.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.model.is_empty() {
            os.write_string(2, &self.model)?;
        }
        if self.playerNumber != 0 {
            os.write_uint32(3, self.playerNumber)?;
        }
        if let Some(ref v) = self.playback.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProDjLinkConnection {
        ProDjLinkConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &ProDjLinkConnection| { &m.address },
                |m: &mut ProDjLinkConnection| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model",
                |m: &ProDjLinkConnection| { &m.model },
                |m: &mut ProDjLinkConnection| { &mut m.model },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "playerNumber",
                |m: &ProDjLinkConnection| { &m.playerNumber },
                |m: &mut ProDjLinkConnection| { &mut m.playerNumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CdjPlayback>>(
                "playback",
                |m: &ProDjLinkConnection| { &m.playback },
                |m: &mut ProDjLinkConnection| { &mut m.playback },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProDjLinkConnection>(
                "ProDjLinkConnection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProDjLinkConnection {
        static instance: ::protobuf::rt::LazyV2<ProDjLinkConnection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProDjLinkConnection::new)
    }
}

impl ::protobuf::Clear for ProDjLinkConnection {
    fn clear(&mut self) {
        self.address.clear();
        self.model.clear();
        self.playerNumber = 0;
        self.playback.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProDjLinkConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProDjLinkConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CdjPlayback {
    // message fields
    pub live: bool,
    pub bpm: f64,
    pub frame: u32,
    pub playback: CdjPlayback_State,
    pub track: ::protobuf::SingularPtrField<CdjPlayback_Track>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CdjPlayback {
    fn default() -> &'a CdjPlayback {
        <CdjPlayback as ::protobuf::Message>::default_instance()
    }
}

impl CdjPlayback {
    pub fn new() -> CdjPlayback {
        ::std::default::Default::default()
    }

    // bool live = 1;


    pub fn get_live(&self) -> bool {
        self.live
    }
    pub fn clear_live(&mut self) {
        self.live = false;
    }

    // Param is passed by value, moved
    pub fn set_live(&mut self, v: bool) {
        self.live = v;
    }

    // double bpm = 2;


    pub fn get_bpm(&self) -> f64 {
        self.bpm
    }
    pub fn clear_bpm(&mut self) {
        self.bpm = 0.;
    }

    // Param is passed by value, moved
    pub fn set_bpm(&mut self, v: f64) {
        self.bpm = v;
    }

    // uint32 frame = 3;


    pub fn get_frame(&self) -> u32 {
        self.frame
    }
    pub fn clear_frame(&mut self) {
        self.frame = 0;
    }

    // Param is passed by value, moved
    pub fn set_frame(&mut self, v: u32) {
        self.frame = v;
    }

    // .mizer.CdjPlayback.State playback = 4;


    pub fn get_playback(&self) -> CdjPlayback_State {
        self.playback
    }
    pub fn clear_playback(&mut self) {
        self.playback = CdjPlayback_State::Loading;
    }

    // Param is passed by value, moved
    pub fn set_playback(&mut self, v: CdjPlayback_State) {
        self.playback = v;
    }

    // .mizer.CdjPlayback.Track track = 5;


    pub fn get_track(&self) -> &CdjPlayback_Track {
        self.track.as_ref().unwrap_or_else(|| <CdjPlayback_Track as ::protobuf::Message>::default_instance())
    }
    pub fn clear_track(&mut self) {
        self.track.clear();
    }

    pub fn has_track(&self) -> bool {
        self.track.is_some()
    }

    // Param is passed by value, moved
    pub fn set_track(&mut self, v: CdjPlayback_Track) {
        self.track = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_track(&mut self) -> &mut CdjPlayback_Track {
        if self.track.is_none() {
            self.track.set_default();
        }
        self.track.as_mut().unwrap()
    }

    // Take field
    pub fn take_track(&mut self) -> CdjPlayback_Track {
        self.track.take().unwrap_or_else(|| CdjPlayback_Track::new())
    }
}

impl ::protobuf::Message for CdjPlayback {
    fn is_initialized(&self) -> bool {
        for v in &self.track {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.live = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.bpm = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.frame = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.playback, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.track)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.live != false {
            my_size += 2;
        }
        if self.bpm != 0. {
            my_size += 9;
        }
        if self.frame != 0 {
            my_size += ::protobuf::rt::value_size(3, self.frame, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.playback != CdjPlayback_State::Loading {
            my_size += ::protobuf::rt::enum_size(4, self.playback);
        }
        if let Some(ref v) = self.track.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.live != false {
            os.write_bool(1, self.live)?;
        }
        if self.bpm != 0. {
            os.write_double(2, self.bpm)?;
        }
        if self.frame != 0 {
            os.write_uint32(3, self.frame)?;
        }
        if self.playback != CdjPlayback_State::Loading {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.playback))?;
        }
        if let Some(ref v) = self.track.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CdjPlayback {
        CdjPlayback::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "live",
                |m: &CdjPlayback| { &m.live },
                |m: &mut CdjPlayback| { &mut m.live },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "bpm",
                |m: &CdjPlayback| { &m.bpm },
                |m: &mut CdjPlayback| { &mut m.bpm },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "frame",
                |m: &CdjPlayback| { &m.frame },
                |m: &mut CdjPlayback| { &mut m.frame },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CdjPlayback_State>>(
                "playback",
                |m: &CdjPlayback| { &m.playback },
                |m: &mut CdjPlayback| { &mut m.playback },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CdjPlayback_Track>>(
                "track",
                |m: &CdjPlayback| { &m.track },
                |m: &mut CdjPlayback| { &mut m.track },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CdjPlayback>(
                "CdjPlayback",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CdjPlayback {
        static instance: ::protobuf::rt::LazyV2<CdjPlayback> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CdjPlayback::new)
    }
}

impl ::protobuf::Clear for CdjPlayback {
    fn clear(&mut self) {
        self.live = false;
        self.bpm = 0.;
        self.frame = 0;
        self.playback = CdjPlayback_State::Loading;
        self.track.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CdjPlayback {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CdjPlayback {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CdjPlayback_Track {
    // message fields
    pub artist: ::std::string::String,
    pub title: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CdjPlayback_Track {
    fn default() -> &'a CdjPlayback_Track {
        <CdjPlayback_Track as ::protobuf::Message>::default_instance()
    }
}

impl CdjPlayback_Track {
    pub fn new() -> CdjPlayback_Track {
        ::std::default::Default::default()
    }

    // string artist = 1;


    pub fn get_artist(&self) -> &str {
        &self.artist
    }
    pub fn clear_artist(&mut self) {
        self.artist.clear();
    }

    // Param is passed by value, moved
    pub fn set_artist(&mut self, v: ::std::string::String) {
        self.artist = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_artist(&mut self) -> &mut ::std::string::String {
        &mut self.artist
    }

    // Take field
    pub fn take_artist(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.artist, ::std::string::String::new())
    }

    // string title = 2;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CdjPlayback_Track {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.artist)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.artist.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.artist);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.title);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.artist.is_empty() {
            os.write_string(1, &self.artist)?;
        }
        if !self.title.is_empty() {
            os.write_string(2, &self.title)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CdjPlayback_Track {
        CdjPlayback_Track::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "artist",
                |m: &CdjPlayback_Track| { &m.artist },
                |m: &mut CdjPlayback_Track| { &mut m.artist },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &CdjPlayback_Track| { &m.title },
                |m: &mut CdjPlayback_Track| { &mut m.title },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CdjPlayback_Track>(
                "CdjPlayback.Track",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CdjPlayback_Track {
        static instance: ::protobuf::rt::LazyV2<CdjPlayback_Track> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CdjPlayback_Track::new)
    }
}

impl ::protobuf::Clear for CdjPlayback_Track {
    fn clear(&mut self) {
        self.artist.clear();
        self.title.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CdjPlayback_Track {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CdjPlayback_Track {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum CdjPlayback_State {
    Loading = 0,
    Playing = 1,
    Cued = 2,
    Cueing = 3,
}

impl ::protobuf::ProtobufEnum for CdjPlayback_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CdjPlayback_State> {
        match value {
            0 => ::std::option::Option::Some(CdjPlayback_State::Loading),
            1 => ::std::option::Option::Some(CdjPlayback_State::Playing),
            2 => ::std::option::Option::Some(CdjPlayback_State::Cued),
            3 => ::std::option::Option::Some(CdjPlayback_State::Cueing),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CdjPlayback_State] = &[
            CdjPlayback_State::Loading,
            CdjPlayback_State::Playing,
            CdjPlayback_State::Cued,
            CdjPlayback_State::Cueing,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CdjPlayback_State>("CdjPlayback.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CdjPlayback_State {
}

impl ::std::default::Default for CdjPlayback_State {
    fn default() -> Self {
        CdjPlayback_State::Loading
    }
}

impl ::protobuf::reflect::ProtobufValue for CdjPlayback_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MqttConnection {
    // message fields
    pub connectionId: ::std::string::String,
    pub url: ::std::string::String,
    // message oneof groups
    pub _username: ::std::option::Option<MqttConnection_oneof__username>,
    pub _password: ::std::option::Option<MqttConnection_oneof__password>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MqttConnection {
    fn default() -> &'a MqttConnection {
        <MqttConnection as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum MqttConnection_oneof__username {
    username(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum MqttConnection_oneof__password {
    password(::std::string::String),
}

impl MqttConnection {
    pub fn new() -> MqttConnection {
        ::std::default::Default::default()
    }

    // string connectionId = 1;


    pub fn get_connectionId(&self) -> &str {
        &self.connectionId
    }
    pub fn clear_connectionId(&mut self) {
        self.connectionId.clear();
    }

    // Param is passed by value, moved
    pub fn set_connectionId(&mut self, v: ::std::string::String) {
        self.connectionId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connectionId(&mut self) -> &mut ::std::string::String {
        &mut self.connectionId
    }

    // Take field
    pub fn take_connectionId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.connectionId, ::std::string::String::new())
    }

    // string url = 2;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // string username = 3;


    pub fn get_username(&self) -> &str {
        match self._username {
            ::std::option::Option::Some(MqttConnection_oneof__username::username(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_username(&mut self) {
        self._username = ::std::option::Option::None;
    }

    pub fn has_username(&self) -> bool {
        match self._username {
            ::std::option::Option::Some(MqttConnection_oneof__username::username(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self._username = ::std::option::Option::Some(MqttConnection_oneof__username::username(v))
    }

    // Mutable pointer to the field.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(MqttConnection_oneof__username::username(_)) = self._username {
        } else {
            self._username = ::std::option::Option::Some(MqttConnection_oneof__username::username(::std::string::String::new()));
        }
        match self._username {
            ::std::option::Option::Some(MqttConnection_oneof__username::username(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        if self.has_username() {
            match self._username.take() {
                ::std::option::Option::Some(MqttConnection_oneof__username::username(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string password = 4;


    pub fn get_password(&self) -> &str {
        match self._password {
            ::std::option::Option::Some(MqttConnection_oneof__password::password(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_password(&mut self) {
        self._password = ::std::option::Option::None;
    }

    pub fn has_password(&self) -> bool {
        match self._password {
            ::std::option::Option::Some(MqttConnection_oneof__password::password(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self._password = ::std::option::Option::Some(MqttConnection_oneof__password::password(v))
    }

    // Mutable pointer to the field.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(MqttConnection_oneof__password::password(_)) = self._password {
        } else {
            self._password = ::std::option::Option::Some(MqttConnection_oneof__password::password(::std::string::String::new()));
        }
        match self._password {
            ::std::option::Option::Some(MqttConnection_oneof__password::password(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        if self.has_password() {
            match self._password.take() {
                ::std::option::Option::Some(MqttConnection_oneof__password::password(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for MqttConnection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.connectionId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._username = ::std::option::Option::Some(MqttConnection_oneof__username::username(is.read_string()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._password = ::std::option::Option::Some(MqttConnection_oneof__password::password(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.connectionId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.connectionId);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.url);
        }
        if let ::std::option::Option::Some(ref v) = self._username {
            match v {
                &MqttConnection_oneof__username::username(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._password {
            match v {
                &MqttConnection_oneof__password::password(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.connectionId.is_empty() {
            os.write_string(1, &self.connectionId)?;
        }
        if !self.url.is_empty() {
            os.write_string(2, &self.url)?;
        }
        if let ::std::option::Option::Some(ref v) = self._username {
            match v {
                &MqttConnection_oneof__username::username(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._password {
            match v {
                &MqttConnection_oneof__password::password(ref v) => {
                    os.write_string(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MqttConnection {
        MqttConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "connectionId",
                |m: &MqttConnection| { &m.connectionId },
                |m: &mut MqttConnection| { &mut m.connectionId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &MqttConnection| { &m.url },
                |m: &mut MqttConnection| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "username",
                MqttConnection::has_username,
                MqttConnection::get_username,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "password",
                MqttConnection::has_password,
                MqttConnection::get_password,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MqttConnection>(
                "MqttConnection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MqttConnection {
        static instance: ::protobuf::rt::LazyV2<MqttConnection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MqttConnection::new)
    }
}

impl ::protobuf::Clear for MqttConnection {
    fn clear(&mut self) {
        self.connectionId.clear();
        self.url.clear();
        self._username = ::std::option::Option::None;
        self._password = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MqttConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MqttConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ConfigureConnectionRequest {
    // message oneof groups
    pub config: ::std::option::Option<ConfigureConnectionRequest_oneof_config>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigureConnectionRequest {
    fn default() -> &'a ConfigureConnectionRequest {
        <ConfigureConnectionRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ConfigureConnectionRequest_oneof_config {
    dmx(DmxConnection),
    mqtt(MqttConnection),
}

impl ConfigureConnectionRequest {
    pub fn new() -> ConfigureConnectionRequest {
        ::std::default::Default::default()
    }

    // .mizer.DmxConnection dmx = 1;


    pub fn get_dmx(&self) -> &DmxConnection {
        match self.config {
            ::std::option::Option::Some(ConfigureConnectionRequest_oneof_config::dmx(ref v)) => v,
            _ => <DmxConnection as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_dmx(&mut self) {
        self.config = ::std::option::Option::None;
    }

    pub fn has_dmx(&self) -> bool {
        match self.config {
            ::std::option::Option::Some(ConfigureConnectionRequest_oneof_config::dmx(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dmx(&mut self, v: DmxConnection) {
        self.config = ::std::option::Option::Some(ConfigureConnectionRequest_oneof_config::dmx(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dmx(&mut self) -> &mut DmxConnection {
        if let ::std::option::Option::Some(ConfigureConnectionRequest_oneof_config::dmx(_)) = self.config {
        } else {
            self.config = ::std::option::Option::Some(ConfigureConnectionRequest_oneof_config::dmx(DmxConnection::new()));
        }
        match self.config {
            ::std::option::Option::Some(ConfigureConnectionRequest_oneof_config::dmx(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dmx(&mut self) -> DmxConnection {
        if self.has_dmx() {
            match self.config.take() {
                ::std::option::Option::Some(ConfigureConnectionRequest_oneof_config::dmx(v)) => v,
                _ => panic!(),
            }
        } else {
            DmxConnection::new()
        }
    }

    // .mizer.MqttConnection mqtt = 2;


    pub fn get_mqtt(&self) -> &MqttConnection {
        match self.config {
            ::std::option::Option::Some(ConfigureConnectionRequest_oneof_config::mqtt(ref v)) => v,
            _ => <MqttConnection as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_mqtt(&mut self) {
        self.config = ::std::option::Option::None;
    }

    pub fn has_mqtt(&self) -> bool {
        match self.config {
            ::std::option::Option::Some(ConfigureConnectionRequest_oneof_config::mqtt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mqtt(&mut self, v: MqttConnection) {
        self.config = ::std::option::Option::Some(ConfigureConnectionRequest_oneof_config::mqtt(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mqtt(&mut self) -> &mut MqttConnection {
        if let ::std::option::Option::Some(ConfigureConnectionRequest_oneof_config::mqtt(_)) = self.config {
        } else {
            self.config = ::std::option::Option::Some(ConfigureConnectionRequest_oneof_config::mqtt(MqttConnection::new()));
        }
        match self.config {
            ::std::option::Option::Some(ConfigureConnectionRequest_oneof_config::mqtt(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mqtt(&mut self) -> MqttConnection {
        if self.has_mqtt() {
            match self.config.take() {
                ::std::option::Option::Some(ConfigureConnectionRequest_oneof_config::mqtt(v)) => v,
                _ => panic!(),
            }
        } else {
            MqttConnection::new()
        }
    }
}

impl ::protobuf::Message for ConfigureConnectionRequest {
    fn is_initialized(&self) -> bool {
        if let Some(ConfigureConnectionRequest_oneof_config::dmx(ref v)) = self.config {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConfigureConnectionRequest_oneof_config::mqtt(ref v)) = self.config {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.config = ::std::option::Option::Some(ConfigureConnectionRequest_oneof_config::dmx(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.config = ::std::option::Option::Some(ConfigureConnectionRequest_oneof_config::mqtt(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.config {
            match v {
                &ConfigureConnectionRequest_oneof_config::dmx(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConfigureConnectionRequest_oneof_config::mqtt(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.config {
            match v {
                &ConfigureConnectionRequest_oneof_config::dmx(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConfigureConnectionRequest_oneof_config::mqtt(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigureConnectionRequest {
        ConfigureConnectionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DmxConnection>(
                "dmx",
                ConfigureConnectionRequest::has_dmx,
                ConfigureConnectionRequest::get_dmx,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MqttConnection>(
                "mqtt",
                ConfigureConnectionRequest::has_mqtt,
                ConfigureConnectionRequest::get_mqtt,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigureConnectionRequest>(
                "ConfigureConnectionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigureConnectionRequest {
        static instance: ::protobuf::rt::LazyV2<ConfigureConnectionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigureConnectionRequest::new)
    }
}

impl ::protobuf::Clear for ConfigureConnectionRequest {
    fn clear(&mut self) {
        self.config = ::std::option::Option::None;
        self.config = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigureConnectionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigureConnectionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11connections.proto\x12\x05mizer\"/\n\x11MonitorDmxRequest\x12\x1a\n\
    \x08outputId\x18\x01\x20\x01(\tR\x08outputId\"M\n\x12MonitorDmxResponse\
    \x127\n\tuniverses\x18\x01\x20\x03(\x0b2\x19.mizer.MonitorDmxUniverseR\t\
    universes\"L\n\x12MonitorDmxUniverse\x12\x1a\n\x08universe\x18\x01\x20\
    \x01(\rR\x08universe\x12\x1a\n\x08channels\x18\x02\x20\x01(\x0cR\x08chan\
    nels\"(\n\x12MonitorMidiRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\"\xbd\x04\n\x13MonitorMidiResponse\x12\x1c\n\ttimestamp\x18\x02\
    \x20\x01(\x04R\ttimestamp\x124\n\x02cc\x18\x03\x20\x01(\x0b2\".mizer.Mon\
    itorMidiResponse.NoteMsgH\0R\x02cc\x12>\n\x07noteOff\x18\x04\x20\x01(\
    \x0b2\".mizer.MonitorMidiResponse.NoteMsgH\0R\x07noteOff\x12<\n\x06noteO\
    n\x18\x05\x20\x01(\x0b2\".mizer.MonitorMidiResponse.NoteMsgH\0R\x06noteO\
    n\x128\n\x05sysEx\x18\x06\x20\x01(\x0b2\x20.mizer.MonitorMidiResponse.Sy\
    sExH\0R\x05sysEx\x12\x1a\n\x07unknown\x18\x07\x20\x01(\x0cH\0R\x07unknow\
    n\x1aM\n\x07NoteMsg\x12\x18\n\x07channel\x18\x01\x20\x01(\rR\x07channel\
    \x12\x12\n\x04note\x18\x02\x20\x01(\rR\x04note\x12\x14\n\x05value\x18\
    \x03\x20\x01(\rR\x05value\x1a\xa3\x01\n\x05SysEx\x12$\n\rmanufacturer1\
    \x18\x01\x20\x01(\rR\rmanufacturer1\x12$\n\rmanufacturer2\x18\x02\x20\
    \x01(\rR\rmanufacturer2\x12$\n\rmanufacturer3\x18\x03\x20\x01(\rR\rmanuf\
    acturer3\x12\x14\n\x05model\x18\x04\x20\x01(\rR\x05model\x12\x12\n\x04da\
    ta\x18\x05\x20\x01(\x0cR\x04dataB\t\n\x07message\"\x17\n\x15GetConnectio\
    nsRequest\"\x1a\n\x18GetDeviceProfilesRequest\"J\n\x0cArtnetConfig\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04host\x18\x02\x20\
    \x01(\tR\x04host\x12\x12\n\x04port\x18\x03\x20\x01(\rR\x04port\"\x20\n\n\
    SacnConfig\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"B\n\x0bConnect\
    ions\x123\n\x0bconnections\x18\x01\x20\x03(\x0b2\x11.mizer.ConnectionR\
    \x0bconnections\"\xc0\x03\n\nConnection\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12(\n\x03dmx\x18\n\x20\x01(\x0b2\x14.mizer.DmxConnecti\
    onH\0R\x03dmx\x12+\n\x04midi\x18\x0b\x20\x01(\x0b2\x15.mizer.MidiConnect\
    ionH\0R\x04midi\x12(\n\x03osc\x18\x0c\x20\x01(\x0b2\x14.mizer.OscConnect\
    ionH\0R\x03osc\x12:\n\tproDJLink\x18\r\x20\x01(\x0b2\x1a.mizer.ProDjLink\
    ConnectionH\0R\tproDJLink\x121\n\x06helios\x18\x0e\x20\x01(\x0b2\x17.miz\
    er.HeliosConnectionH\0R\x06helios\x12=\n\netherDream\x18\x0f\x20\x01(\
    \x0b2\x1b.mizer.EtherDreamConnectionH\0R\netherDream\x124\n\x07gamepad\
    \x18\x10\x20\x01(\x0b2\x18.mizer.GamepadConnectionH\0R\x07gamepad\x12+\n\
    \x04mqtt\x18\x11\x20\x01(\x0b2\x15.mizer.MqttConnectionH\0R\x04mqttB\x0c\
    \n\nconnection\"\x8d\x01\n\rDmxConnection\x12\x1a\n\x08outputId\x18\x01\
    \x20\x01(\tR\x08outputId\x12-\n\x06artnet\x18\x03\x20\x01(\x0b2\x13.mize\
    r.ArtnetConfigH\0R\x06artnet\x12'\n\x04sacn\x18\x04\x20\x01(\x0b2\x11.mi\
    zer.SacnConfigH\0R\x04sacnB\x08\n\x06config\"B\n\x10HeliosConnection\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1a\n\x08firmware\x18\x02\
    \x20\x01(\rR\x08firmware\"*\n\x14EtherDreamConnection\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\"7\n\x11GamepadConnection\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\
    \"O\n\x0eMidiConnection\x12*\n\x0edevice_profile\x18\x01\x20\x01(\tH\0R\
    \rdeviceProfile\x88\x01\x01B\x11\n\x0f_device_profile\"J\n\x12MidiDevice\
    Profiles\x124\n\x08profiles\x18\x01\x20\x03(\x0b2\x18.mizer.MidiDevicePr\
    ofileR\x08profiles\"\x8f\x05\n\x11MidiDeviceProfile\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\tR\x02id\x12\"\n\x0cmanufacturer\x18\x02\x20\x01(\tR\x0cma\
    nufacturer\x12\x14\n\x05model\x18\x03\x20\x01(\tR\x05model\x12\x1b\n\x06\
    layout\x18\x04\x20\x01(\tH\0R\x06layout\x88\x01\x01\x123\n\x05pages\x18\
    \x05\x20\x03(\x0b2\x1d.mizer.MidiDeviceProfile.PageR\x05pages\x1a\x90\
    \x01\n\x04Page\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x126\n\x06g\
    roups\x18\x02\x20\x03(\x0b2\x1e.mizer.MidiDeviceProfile.GroupR\x06groups\
    \x12<\n\x08controls\x18\x03\x20\x03(\x0b2\x20.mizer.MidiDeviceProfile.Co\
    ntrolR\x08controls\x1aY\n\x05Group\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x12<\n\x08controls\x18\x02\x20\x03(\x0b2\x20.mizer.MidiDevicePr\
    ofile.ControlR\x08controls\x1a\xc3\x01\n\x07Control\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\
    \x18\n\x07channel\x18\x03\x20\x01(\rR\x07channel\x12\x12\n\x04note\x18\
    \x04\x20\x01(\rR\x04note\x12G\n\x0ccontrol_type\x18\x05\x20\x01(\x0e2$.m\
    izer.MidiDeviceProfile.ControlTypeR\x0bcontrolType\x12\x1d\n\nhas_output\
    \x18\x06\x20\x01(\x08R\thasOutput\"\x1f\n\x0bControlType\x12\x08\n\x04No\
    te\x10\0\x12\x06\n\x02CC\x10\x01B\t\n\x07_layout\"v\n\rOscConnection\x12\
    \x1d\n\ninput_port\x18\x01\x20\x01(\rR\tinputPort\x12\x1f\n\x0boutput_po\
    rt\x18\x02\x20\x01(\rR\noutputPort\x12%\n\x0eoutput_address\x18\x03\x20\
    \x01(\tR\routputAddress\"\x99\x01\n\x13ProDjLinkConnection\x12\x18\n\x07\
    address\x18\x01\x20\x01(\tR\x07address\x12\x14\n\x05model\x18\x02\x20\
    \x01(\tR\x05model\x12\"\n\x0cplayerNumber\x18\x03\x20\x01(\rR\x0cplayerN\
    umber\x12.\n\x08playback\x18\x05\x20\x01(\x0b2\x12.mizer.CdjPlaybackR\
    \x08playback\"\x9f\x02\n\x0bCdjPlayback\x12\x12\n\x04live\x18\x01\x20\
    \x01(\x08R\x04live\x12\x10\n\x03bpm\x18\x02\x20\x01(\x01R\x03bpm\x12\x14\
    \n\x05frame\x18\x03\x20\x01(\rR\x05frame\x124\n\x08playback\x18\x04\x20\
    \x01(\x0e2\x18.mizer.CdjPlayback.StateR\x08playback\x12.\n\x05track\x18\
    \x05\x20\x01(\x0b2\x18.mizer.CdjPlayback.TrackR\x05track\x1a5\n\x05Track\
    \x12\x16\n\x06artist\x18\x01\x20\x01(\tR\x06artist\x12\x14\n\x05title\
    \x18\x02\x20\x01(\tR\x05title\"7\n\x05State\x12\x0b\n\x07Loading\x10\0\
    \x12\x0b\n\x07Playing\x10\x01\x12\x08\n\x04Cued\x10\x02\x12\n\n\x06Cuein\
    g\x10\x03\"\xa2\x01\n\x0eMqttConnection\x12\"\n\x0cconnectionId\x18\x01\
    \x20\x01(\tR\x0cconnectionId\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\
    \x12\x1f\n\x08username\x18\x03\x20\x01(\tH\0R\x08username\x88\x01\x01\
    \x12\x1f\n\x08password\x18\x04\x20\x01(\tH\x01R\x08password\x88\x01\x01B\
    \x0b\n\t_usernameB\x0b\n\t_password\"}\n\x1aConfigureConnectionRequest\
    \x12(\n\x03dmx\x18\x01\x20\x01(\x0b2\x14.mizer.DmxConnectionH\0R\x03dmx\
    \x12+\n\x04mqtt\x18\x02\x20\x01(\x0b2\x15.mizer.MqttConnectionH\0R\x04mq\
    ttB\x08\n\x06config2\xc8\x04\n\x0eConnectionsApi\x12D\n\x0eGetConnection\
    s\x12\x1c.mizer.GetConnectionsRequest\x1a\x12.mizer.Connections\"\0\x12C\
    \n\nMonitorDmx\x12\x18.mizer.MonitorDmxRequest\x1a\x19.mizer.MonitorDmxR\
    esponse\"\0\x12H\n\x0bMonitorMidi\x12\x19.mizer.MonitorMidiRequest\x1a\
    \x1a.mizer.MonitorMidiResponse\"\00\x01\x12@\n\x13AddArtnetConnection\
    \x12\x13.mizer.ArtnetConfig\x1a\x12.mizer.Connections\"\0\x12<\n\x11AddS\
    acnConnection\x12\x11.mizer.SacnConfig\x1a\x12.mizer.Connections\"\0\x12\
    U\n\x15GetMidiDeviceProfiles\x12\x1f.mizer.GetDeviceProfilesRequest\x1a\
    \x19.mizer.MidiDeviceProfiles\"\0\x12;\n\x10DeleteConnection\x12\x11.miz\
    er.Connection\x1a\x12.mizer.Connections\"\0\x12M\n\x13ConfigureConnectio\
    n\x12!.mizer.ConfigureConnectionRequest\x1a\x11.mizer.Connection\"\0b\
    \x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
