// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `nodes.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AddNodeRequest {
    // message fields
    pub field_type: Node_NodeType,
    pub position: ::protobuf::SingularPtrField<NodePosition>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddNodeRequest {
    fn default() -> &'a AddNodeRequest {
        <AddNodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddNodeRequest {
    pub fn new() -> AddNodeRequest {
        ::std::default::Default::default()
    }

    // .mizer.Node.NodeType type = 1;


    pub fn get_field_type(&self) -> Node_NodeType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Node_NodeType::Fader;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Node_NodeType) {
        self.field_type = v;
    }

    // .mizer.NodePosition position = 2;


    pub fn get_position(&self) -> &NodePosition {
        self.position.as_ref().unwrap_or_else(|| <NodePosition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: NodePosition) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut NodePosition {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> NodePosition {
        self.position.take().unwrap_or_else(|| NodePosition::new())
    }
}

impl ::protobuf::Message for AddNodeRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Node_NodeType::Fader {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Node_NodeType::Fader {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddNodeRequest {
        AddNodeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Node_NodeType>>(
                "type",
                |m: &AddNodeRequest| { &m.field_type },
                |m: &mut AddNodeRequest| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodePosition>>(
                "position",
                |m: &AddNodeRequest| { &m.position },
                |m: &mut AddNodeRequest| { &mut m.position },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddNodeRequest>(
                "AddNodeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddNodeRequest {
        static instance: ::protobuf::rt::LazyV2<AddNodeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddNodeRequest::new)
    }
}

impl ::protobuf::Clear for AddNodeRequest {
    fn clear(&mut self) {
        self.field_type = Node_NodeType::Fader;
        self.position.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddNodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddNodeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NodesRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodesRequest {
    fn default() -> &'a NodesRequest {
        <NodesRequest as ::protobuf::Message>::default_instance()
    }
}

impl NodesRequest {
    pub fn new() -> NodesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for NodesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodesRequest {
        NodesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodesRequest>(
                "NodesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodesRequest {
        static instance: ::protobuf::rt::LazyV2<NodesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodesRequest::new)
    }
}

impl ::protobuf::Clear for NodesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct WriteControl {
    // message fields
    pub path: ::std::string::String,
    pub port: ::std::string::String,
    pub value: f64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WriteControl {
    fn default() -> &'a WriteControl {
        <WriteControl as ::protobuf::Message>::default_instance()
    }
}

impl WriteControl {
    pub fn new() -> WriteControl {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // string port = 2;


    pub fn get_port(&self) -> &str {
        &self.port
    }
    pub fn clear_port(&mut self) {
        self.port.clear();
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: ::std::string::String) {
        self.port = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port(&mut self) -> &mut ::std::string::String {
        &mut self.port
    }

    // Take field
    pub fn take_port(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.port, ::std::string::String::new())
    }

    // double value = 3;


    pub fn get_value(&self) -> f64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f64) {
        self.value = v;
    }
}

impl ::protobuf::Message for WriteControl {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.port)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if !self.port.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.port);
        }
        if self.value != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if !self.port.is_empty() {
            os.write_string(2, &self.port)?;
        }
        if self.value != 0. {
            os.write_double(3, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteControl {
        WriteControl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &WriteControl| { &m.path },
                |m: &mut WriteControl| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "port",
                |m: &WriteControl| { &m.port },
                |m: &mut WriteControl| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "value",
                |m: &WriteControl| { &m.value },
                |m: &mut WriteControl| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WriteControl>(
                "WriteControl",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WriteControl {
        static instance: ::protobuf::rt::LazyV2<WriteControl> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WriteControl::new)
    }
}

impl ::protobuf::Clear for WriteControl {
    fn clear(&mut self) {
        self.path.clear();
        self.port.clear();
        self.value = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteControl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct WriteResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WriteResponse {
    fn default() -> &'a WriteResponse {
        <WriteResponse as ::protobuf::Message>::default_instance()
    }
}

impl WriteResponse {
    pub fn new() -> WriteResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for WriteResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteResponse {
        WriteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WriteResponse>(
                "WriteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WriteResponse {
        static instance: ::protobuf::rt::LazyV2<WriteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WriteResponse::new)
    }
}

impl ::protobuf::Clear for WriteResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UpdateNodeConfigRequest {
    // message fields
    pub path: ::std::string::String,
    pub config: ::protobuf::SingularPtrField<NodeConfig>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateNodeConfigRequest {
    fn default() -> &'a UpdateNodeConfigRequest {
        <UpdateNodeConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateNodeConfigRequest {
    pub fn new() -> UpdateNodeConfigRequest {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // .mizer.NodeConfig config = 2;


    pub fn get_config(&self) -> &NodeConfig {
        self.config.as_ref().unwrap_or_else(|| <NodeConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: NodeConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut NodeConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> NodeConfig {
        self.config.take().unwrap_or_else(|| NodeConfig::new())
    }
}

impl ::protobuf::Message for UpdateNodeConfigRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateNodeConfigRequest {
        UpdateNodeConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &UpdateNodeConfigRequest| { &m.path },
                |m: &mut UpdateNodeConfigRequest| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeConfig>>(
                "config",
                |m: &UpdateNodeConfigRequest| { &m.config },
                |m: &mut UpdateNodeConfigRequest| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateNodeConfigRequest>(
                "UpdateNodeConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateNodeConfigRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateNodeConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateNodeConfigRequest::new)
    }
}

impl ::protobuf::Clear for UpdateNodeConfigRequest {
    fn clear(&mut self) {
        self.path.clear();
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateNodeConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateNodeConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UpdateNodeConfigResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateNodeConfigResponse {
    fn default() -> &'a UpdateNodeConfigResponse {
        <UpdateNodeConfigResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateNodeConfigResponse {
    pub fn new() -> UpdateNodeConfigResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateNodeConfigResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateNodeConfigResponse {
        UpdateNodeConfigResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateNodeConfigResponse>(
                "UpdateNodeConfigResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateNodeConfigResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateNodeConfigResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateNodeConfigResponse::new)
    }
}

impl ::protobuf::Clear for UpdateNodeConfigResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateNodeConfigResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateNodeConfigResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MoveNodeRequest {
    // message fields
    pub path: ::std::string::String,
    pub position: ::protobuf::SingularPtrField<NodePosition>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoveNodeRequest {
    fn default() -> &'a MoveNodeRequest {
        <MoveNodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoveNodeRequest {
    pub fn new() -> MoveNodeRequest {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // .mizer.NodePosition position = 2;


    pub fn get_position(&self) -> &NodePosition {
        self.position.as_ref().unwrap_or_else(|| <NodePosition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: NodePosition) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut NodePosition {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> NodePosition {
        self.position.take().unwrap_or_else(|| NodePosition::new())
    }
}

impl ::protobuf::Message for MoveNodeRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoveNodeRequest {
        MoveNodeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &MoveNodeRequest| { &m.path },
                |m: &mut MoveNodeRequest| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodePosition>>(
                "position",
                |m: &MoveNodeRequest| { &m.position },
                |m: &mut MoveNodeRequest| { &mut m.position },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoveNodeRequest>(
                "MoveNodeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoveNodeRequest {
        static instance: ::protobuf::rt::LazyV2<MoveNodeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoveNodeRequest::new)
    }
}

impl ::protobuf::Clear for MoveNodeRequest {
    fn clear(&mut self) {
        self.path.clear();
        self.position.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoveNodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveNodeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MoveNodeResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoveNodeResponse {
    fn default() -> &'a MoveNodeResponse {
        <MoveNodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl MoveNodeResponse {
    pub fn new() -> MoveNodeResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MoveNodeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoveNodeResponse {
        MoveNodeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoveNodeResponse>(
                "MoveNodeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoveNodeResponse {
        static instance: ::protobuf::rt::LazyV2<MoveNodeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoveNodeResponse::new)
    }
}

impl ::protobuf::Clear for MoveNodeResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoveNodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveNodeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ShowNodeRequest {
    // message fields
    pub path: ::std::string::String,
    pub position: ::protobuf::SingularPtrField<NodePosition>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShowNodeRequest {
    fn default() -> &'a ShowNodeRequest {
        <ShowNodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl ShowNodeRequest {
    pub fn new() -> ShowNodeRequest {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // .mizer.NodePosition position = 2;


    pub fn get_position(&self) -> &NodePosition {
        self.position.as_ref().unwrap_or_else(|| <NodePosition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: NodePosition) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut NodePosition {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> NodePosition {
        self.position.take().unwrap_or_else(|| NodePosition::new())
    }
}

impl ::protobuf::Message for ShowNodeRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShowNodeRequest {
        ShowNodeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &ShowNodeRequest| { &m.path },
                |m: &mut ShowNodeRequest| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodePosition>>(
                "position",
                |m: &ShowNodeRequest| { &m.position },
                |m: &mut ShowNodeRequest| { &mut m.position },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShowNodeRequest>(
                "ShowNodeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShowNodeRequest {
        static instance: ::protobuf::rt::LazyV2<ShowNodeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShowNodeRequest::new)
    }
}

impl ::protobuf::Clear for ShowNodeRequest {
    fn clear(&mut self) {
        self.path.clear();
        self.position.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShowNodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShowNodeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ShowNodeResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShowNodeResponse {
    fn default() -> &'a ShowNodeResponse {
        <ShowNodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl ShowNodeResponse {
    pub fn new() -> ShowNodeResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ShowNodeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShowNodeResponse {
        ShowNodeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShowNodeResponse>(
                "ShowNodeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShowNodeResponse {
        static instance: ::protobuf::rt::LazyV2<ShowNodeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShowNodeResponse::new)
    }
}

impl ::protobuf::Clear for ShowNodeResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShowNodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShowNodeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DeleteNodeRequest {
    // message fields
    pub path: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteNodeRequest {
    fn default() -> &'a DeleteNodeRequest {
        <DeleteNodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteNodeRequest {
    pub fn new() -> DeleteNodeRequest {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteNodeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteNodeRequest {
        DeleteNodeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &DeleteNodeRequest| { &m.path },
                |m: &mut DeleteNodeRequest| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteNodeRequest>(
                "DeleteNodeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteNodeRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteNodeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteNodeRequest::new)
    }
}

impl ::protobuf::Clear for DeleteNodeRequest {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteNodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteNodeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DeleteNodeResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteNodeResponse {
    fn default() -> &'a DeleteNodeResponse {
        <DeleteNodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteNodeResponse {
    pub fn new() -> DeleteNodeResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeleteNodeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteNodeResponse {
        DeleteNodeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteNodeResponse>(
                "DeleteNodeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteNodeResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteNodeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteNodeResponse::new)
    }
}

impl ::protobuf::Clear for DeleteNodeResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteNodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteNodeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Nodes {
    // message fields
    pub nodes: ::protobuf::RepeatedField<Node>,
    pub channels: ::protobuf::RepeatedField<NodeConnection>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Nodes {
    fn default() -> &'a Nodes {
        <Nodes as ::protobuf::Message>::default_instance()
    }
}

impl Nodes {
    pub fn new() -> Nodes {
        ::std::default::Default::default()
    }

    // repeated .mizer.Node nodes = 1;


    pub fn get_nodes(&self) -> &[Node] {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<Node>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::protobuf::RepeatedField<Node> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::protobuf::RepeatedField<Node> {
        ::std::mem::replace(&mut self.nodes, ::protobuf::RepeatedField::new())
    }

    // repeated .mizer.NodeConnection channels = 2;


    pub fn get_channels(&self) -> &[NodeConnection] {
        &self.channels
    }
    pub fn clear_channels(&mut self) {
        self.channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: ::protobuf::RepeatedField<NodeConnection>) {
        self.channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channels(&mut self) -> &mut ::protobuf::RepeatedField<NodeConnection> {
        &mut self.channels
    }

    // Take field
    pub fn take_channels(&mut self) -> ::protobuf::RepeatedField<NodeConnection> {
        ::std::mem::replace(&mut self.channels, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Nodes {
    fn is_initialized(&self) -> bool {
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.channels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodes)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nodes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.channels {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Nodes {
        Nodes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Node>>(
                "nodes",
                |m: &Nodes| { &m.nodes },
                |m: &mut Nodes| { &mut m.nodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeConnection>>(
                "channels",
                |m: &Nodes| { &m.channels },
                |m: &mut Nodes| { &mut m.channels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Nodes>(
                "Nodes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Nodes {
        static instance: ::protobuf::rt::LazyV2<Nodes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Nodes::new)
    }
}

impl ::protobuf::Clear for Nodes {
    fn clear(&mut self) {
        self.nodes.clear();
        self.channels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Nodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Nodes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NodeConnection {
    // message fields
    pub targetNode: ::std::string::String,
    pub targetPort: ::protobuf::SingularPtrField<Port>,
    pub sourceNode: ::std::string::String,
    pub sourcePort: ::protobuf::SingularPtrField<Port>,
    pub protocol: ChannelProtocol,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeConnection {
    fn default() -> &'a NodeConnection {
        <NodeConnection as ::protobuf::Message>::default_instance()
    }
}

impl NodeConnection {
    pub fn new() -> NodeConnection {
        ::std::default::Default::default()
    }

    // string targetNode = 1;


    pub fn get_targetNode(&self) -> &str {
        &self.targetNode
    }
    pub fn clear_targetNode(&mut self) {
        self.targetNode.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetNode(&mut self, v: ::std::string::String) {
        self.targetNode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetNode(&mut self) -> &mut ::std::string::String {
        &mut self.targetNode
    }

    // Take field
    pub fn take_targetNode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.targetNode, ::std::string::String::new())
    }

    // .mizer.Port targetPort = 2;


    pub fn get_targetPort(&self) -> &Port {
        self.targetPort.as_ref().unwrap_or_else(|| <Port as ::protobuf::Message>::default_instance())
    }
    pub fn clear_targetPort(&mut self) {
        self.targetPort.clear();
    }

    pub fn has_targetPort(&self) -> bool {
        self.targetPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetPort(&mut self, v: Port) {
        self.targetPort = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetPort(&mut self) -> &mut Port {
        if self.targetPort.is_none() {
            self.targetPort.set_default();
        }
        self.targetPort.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetPort(&mut self) -> Port {
        self.targetPort.take().unwrap_or_else(|| Port::new())
    }

    // string sourceNode = 3;


    pub fn get_sourceNode(&self) -> &str {
        &self.sourceNode
    }
    pub fn clear_sourceNode(&mut self) {
        self.sourceNode.clear();
    }

    // Param is passed by value, moved
    pub fn set_sourceNode(&mut self, v: ::std::string::String) {
        self.sourceNode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sourceNode(&mut self) -> &mut ::std::string::String {
        &mut self.sourceNode
    }

    // Take field
    pub fn take_sourceNode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sourceNode, ::std::string::String::new())
    }

    // .mizer.Port sourcePort = 4;


    pub fn get_sourcePort(&self) -> &Port {
        self.sourcePort.as_ref().unwrap_or_else(|| <Port as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sourcePort(&mut self) {
        self.sourcePort.clear();
    }

    pub fn has_sourcePort(&self) -> bool {
        self.sourcePort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sourcePort(&mut self, v: Port) {
        self.sourcePort = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sourcePort(&mut self) -> &mut Port {
        if self.sourcePort.is_none() {
            self.sourcePort.set_default();
        }
        self.sourcePort.as_mut().unwrap()
    }

    // Take field
    pub fn take_sourcePort(&mut self) -> Port {
        self.sourcePort.take().unwrap_or_else(|| Port::new())
    }

    // .mizer.ChannelProtocol protocol = 5;


    pub fn get_protocol(&self) -> ChannelProtocol {
        self.protocol
    }
    pub fn clear_protocol(&mut self) {
        self.protocol = ChannelProtocol::SINGLE;
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ChannelProtocol) {
        self.protocol = v;
    }
}

impl ::protobuf::Message for NodeConnection {
    fn is_initialized(&self) -> bool {
        for v in &self.targetPort {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sourcePort {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.targetNode)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.targetPort)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sourceNode)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sourcePort)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.protocol, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.targetNode.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.targetNode);
        }
        if let Some(ref v) = self.targetPort.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.sourceNode.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.sourceNode);
        }
        if let Some(ref v) = self.sourcePort.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.protocol != ChannelProtocol::SINGLE {
            my_size += ::protobuf::rt::enum_size(5, self.protocol);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.targetNode.is_empty() {
            os.write_string(1, &self.targetNode)?;
        }
        if let Some(ref v) = self.targetPort.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.sourceNode.is_empty() {
            os.write_string(3, &self.sourceNode)?;
        }
        if let Some(ref v) = self.sourcePort.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.protocol != ChannelProtocol::SINGLE {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.protocol))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeConnection {
        NodeConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "targetNode",
                |m: &NodeConnection| { &m.targetNode },
                |m: &mut NodeConnection| { &mut m.targetNode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Port>>(
                "targetPort",
                |m: &NodeConnection| { &m.targetPort },
                |m: &mut NodeConnection| { &mut m.targetPort },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sourceNode",
                |m: &NodeConnection| { &m.sourceNode },
                |m: &mut NodeConnection| { &mut m.sourceNode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Port>>(
                "sourcePort",
                |m: &NodeConnection| { &m.sourcePort },
                |m: &mut NodeConnection| { &mut m.sourcePort },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ChannelProtocol>>(
                "protocol",
                |m: &NodeConnection| { &m.protocol },
                |m: &mut NodeConnection| { &mut m.protocol },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeConnection>(
                "NodeConnection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeConnection {
        static instance: ::protobuf::rt::LazyV2<NodeConnection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeConnection::new)
    }
}

impl ::protobuf::Clear for NodeConnection {
    fn clear(&mut self) {
        self.targetNode.clear();
        self.targetPort.clear();
        self.sourceNode.clear();
        self.sourcePort.clear();
        self.protocol = ChannelProtocol::SINGLE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Node {
    // message fields
    pub field_type: Node_NodeType,
    pub path: ::std::string::String,
    pub inputs: ::protobuf::RepeatedField<Port>,
    pub outputs: ::protobuf::RepeatedField<Port>,
    pub designer: ::protobuf::SingularPtrField<NodeDesigner>,
    pub preview: Node_NodePreviewType,
    pub config: ::protobuf::SingularPtrField<NodeConfig>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Node {
    fn default() -> &'a Node {
        <Node as ::protobuf::Message>::default_instance()
    }
}

impl Node {
    pub fn new() -> Node {
        ::std::default::Default::default()
    }

    // .mizer.Node.NodeType type = 1;


    pub fn get_field_type(&self) -> Node_NodeType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Node_NodeType::Fader;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Node_NodeType) {
        self.field_type = v;
    }

    // string path = 2;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // repeated .mizer.Port inputs = 3;


    pub fn get_inputs(&self) -> &[Port] {
        &self.inputs
    }
    pub fn clear_inputs(&mut self) {
        self.inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inputs(&mut self, v: ::protobuf::RepeatedField<Port>) {
        self.inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inputs(&mut self) -> &mut ::protobuf::RepeatedField<Port> {
        &mut self.inputs
    }

    // Take field
    pub fn take_inputs(&mut self) -> ::protobuf::RepeatedField<Port> {
        ::std::mem::replace(&mut self.inputs, ::protobuf::RepeatedField::new())
    }

    // repeated .mizer.Port outputs = 4;


    pub fn get_outputs(&self) -> &[Port] {
        &self.outputs
    }
    pub fn clear_outputs(&mut self) {
        self.outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputs(&mut self, v: ::protobuf::RepeatedField<Port>) {
        self.outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputs(&mut self) -> &mut ::protobuf::RepeatedField<Port> {
        &mut self.outputs
    }

    // Take field
    pub fn take_outputs(&mut self) -> ::protobuf::RepeatedField<Port> {
        ::std::mem::replace(&mut self.outputs, ::protobuf::RepeatedField::new())
    }

    // .mizer.NodeDesigner designer = 5;


    pub fn get_designer(&self) -> &NodeDesigner {
        self.designer.as_ref().unwrap_or_else(|| <NodeDesigner as ::protobuf::Message>::default_instance())
    }
    pub fn clear_designer(&mut self) {
        self.designer.clear();
    }

    pub fn has_designer(&self) -> bool {
        self.designer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_designer(&mut self, v: NodeDesigner) {
        self.designer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_designer(&mut self) -> &mut NodeDesigner {
        if self.designer.is_none() {
            self.designer.set_default();
        }
        self.designer.as_mut().unwrap()
    }

    // Take field
    pub fn take_designer(&mut self) -> NodeDesigner {
        self.designer.take().unwrap_or_else(|| NodeDesigner::new())
    }

    // .mizer.Node.NodePreviewType preview = 6;


    pub fn get_preview(&self) -> Node_NodePreviewType {
        self.preview
    }
    pub fn clear_preview(&mut self) {
        self.preview = Node_NodePreviewType::History;
    }

    // Param is passed by value, moved
    pub fn set_preview(&mut self, v: Node_NodePreviewType) {
        self.preview = v;
    }

    // .mizer.NodeConfig config = 7;


    pub fn get_config(&self) -> &NodeConfig {
        self.config.as_ref().unwrap_or_else(|| <NodeConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: NodeConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut NodeConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> NodeConfig {
        self.config.take().unwrap_or_else(|| NodeConfig::new())
    }
}

impl ::protobuf::Message for Node {
    fn is_initialized(&self) -> bool {
        for v in &self.inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.designer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inputs)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outputs)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.designer)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.preview, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Node_NodeType::Fader {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.designer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.preview != Node_NodePreviewType::History {
            my_size += ::protobuf::rt::enum_size(6, self.preview);
        }
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Node_NodeType::Fader {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        for v in &self.inputs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.outputs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.designer.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.preview != Node_NodePreviewType::History {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.preview))?;
        }
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Node {
        Node::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Node_NodeType>>(
                "type",
                |m: &Node| { &m.field_type },
                |m: &mut Node| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &Node| { &m.path },
                |m: &mut Node| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Port>>(
                "inputs",
                |m: &Node| { &m.inputs },
                |m: &mut Node| { &mut m.inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Port>>(
                "outputs",
                |m: &Node| { &m.outputs },
                |m: &mut Node| { &mut m.outputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeDesigner>>(
                "designer",
                |m: &Node| { &m.designer },
                |m: &mut Node| { &mut m.designer },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Node_NodePreviewType>>(
                "preview",
                |m: &Node| { &m.preview },
                |m: &mut Node| { &mut m.preview },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeConfig>>(
                "config",
                |m: &Node| { &m.config },
                |m: &mut Node| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Node>(
                "Node",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Node {
        static instance: ::protobuf::rt::LazyV2<Node> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Node::new)
    }
}

impl ::protobuf::Clear for Node {
    fn clear(&mut self) {
        self.field_type = Node_NodeType::Fader;
        self.path.clear();
        self.inputs.clear();
        self.outputs.clear();
        self.designer.clear();
        self.preview = Node_NodePreviewType::History;
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Node {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Node {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Node_NodeType {
    Fader = 0,
    Button = 1,
    Oscillator = 2,
    Clock = 3,
    Script = 4,
    Envelope = 5,
    Sequence = 6,
    Select = 7,
    Merge = 8,
    Threshold = 9,
    DmxOutput = 10,
    OscInput = 11,
    OscOutput = 12,
    MidiInput = 13,
    MidiOutput = 14,
    Sequencer = 15,
    Fixture = 16,
    Programmer = 17,
    Group = 18,
    Preset = 19,
    VideoFile = 20,
    VideoOutput = 21,
    VideoEffect = 22,
    VideoColorBalance = 23,
    VideoTransform = 24,
    PixelToDmx = 30,
    PixelPattern = 31,
    OpcOutput = 32,
    Laser = 40,
    IldaFile = 41,
    Gamepad = 45,
    ColorRgb = 50,
    ColorHsv = 51,
}

impl ::protobuf::ProtobufEnum for Node_NodeType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Node_NodeType> {
        match value {
            0 => ::std::option::Option::Some(Node_NodeType::Fader),
            1 => ::std::option::Option::Some(Node_NodeType::Button),
            2 => ::std::option::Option::Some(Node_NodeType::Oscillator),
            3 => ::std::option::Option::Some(Node_NodeType::Clock),
            4 => ::std::option::Option::Some(Node_NodeType::Script),
            5 => ::std::option::Option::Some(Node_NodeType::Envelope),
            6 => ::std::option::Option::Some(Node_NodeType::Sequence),
            7 => ::std::option::Option::Some(Node_NodeType::Select),
            8 => ::std::option::Option::Some(Node_NodeType::Merge),
            9 => ::std::option::Option::Some(Node_NodeType::Threshold),
            10 => ::std::option::Option::Some(Node_NodeType::DmxOutput),
            11 => ::std::option::Option::Some(Node_NodeType::OscInput),
            12 => ::std::option::Option::Some(Node_NodeType::OscOutput),
            13 => ::std::option::Option::Some(Node_NodeType::MidiInput),
            14 => ::std::option::Option::Some(Node_NodeType::MidiOutput),
            15 => ::std::option::Option::Some(Node_NodeType::Sequencer),
            16 => ::std::option::Option::Some(Node_NodeType::Fixture),
            17 => ::std::option::Option::Some(Node_NodeType::Programmer),
            18 => ::std::option::Option::Some(Node_NodeType::Group),
            19 => ::std::option::Option::Some(Node_NodeType::Preset),
            20 => ::std::option::Option::Some(Node_NodeType::VideoFile),
            21 => ::std::option::Option::Some(Node_NodeType::VideoOutput),
            22 => ::std::option::Option::Some(Node_NodeType::VideoEffect),
            23 => ::std::option::Option::Some(Node_NodeType::VideoColorBalance),
            24 => ::std::option::Option::Some(Node_NodeType::VideoTransform),
            30 => ::std::option::Option::Some(Node_NodeType::PixelToDmx),
            31 => ::std::option::Option::Some(Node_NodeType::PixelPattern),
            32 => ::std::option::Option::Some(Node_NodeType::OpcOutput),
            40 => ::std::option::Option::Some(Node_NodeType::Laser),
            41 => ::std::option::Option::Some(Node_NodeType::IldaFile),
            45 => ::std::option::Option::Some(Node_NodeType::Gamepad),
            50 => ::std::option::Option::Some(Node_NodeType::ColorRgb),
            51 => ::std::option::Option::Some(Node_NodeType::ColorHsv),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Node_NodeType] = &[
            Node_NodeType::Fader,
            Node_NodeType::Button,
            Node_NodeType::Oscillator,
            Node_NodeType::Clock,
            Node_NodeType::Script,
            Node_NodeType::Envelope,
            Node_NodeType::Sequence,
            Node_NodeType::Select,
            Node_NodeType::Merge,
            Node_NodeType::Threshold,
            Node_NodeType::DmxOutput,
            Node_NodeType::OscInput,
            Node_NodeType::OscOutput,
            Node_NodeType::MidiInput,
            Node_NodeType::MidiOutput,
            Node_NodeType::Sequencer,
            Node_NodeType::Fixture,
            Node_NodeType::Programmer,
            Node_NodeType::Group,
            Node_NodeType::Preset,
            Node_NodeType::VideoFile,
            Node_NodeType::VideoOutput,
            Node_NodeType::VideoEffect,
            Node_NodeType::VideoColorBalance,
            Node_NodeType::VideoTransform,
            Node_NodeType::PixelToDmx,
            Node_NodeType::PixelPattern,
            Node_NodeType::OpcOutput,
            Node_NodeType::Laser,
            Node_NodeType::IldaFile,
            Node_NodeType::Gamepad,
            Node_NodeType::ColorRgb,
            Node_NodeType::ColorHsv,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Node_NodeType>("Node.NodeType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Node_NodeType {
}

impl ::std::default::Default for Node_NodeType {
    fn default() -> Self {
        Node_NodeType::Fader
    }
}

impl ::protobuf::reflect::ProtobufValue for Node_NodeType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Node_NodePreviewType {
    History = 0,
    Waveform = 1,
    Multiple = 2,
    Texture = 3,
    None = 4,
}

impl ::protobuf::ProtobufEnum for Node_NodePreviewType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Node_NodePreviewType> {
        match value {
            0 => ::std::option::Option::Some(Node_NodePreviewType::History),
            1 => ::std::option::Option::Some(Node_NodePreviewType::Waveform),
            2 => ::std::option::Option::Some(Node_NodePreviewType::Multiple),
            3 => ::std::option::Option::Some(Node_NodePreviewType::Texture),
            4 => ::std::option::Option::Some(Node_NodePreviewType::None),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Node_NodePreviewType] = &[
            Node_NodePreviewType::History,
            Node_NodePreviewType::Waveform,
            Node_NodePreviewType::Multiple,
            Node_NodePreviewType::Texture,
            Node_NodePreviewType::None,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Node_NodePreviewType>("Node.NodePreviewType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Node_NodePreviewType {
}

impl ::std::default::Default for Node_NodePreviewType {
    fn default() -> Self {
        Node_NodePreviewType::History
    }
}

impl ::protobuf::reflect::ProtobufValue for Node_NodePreviewType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NodeConfig {
    // message oneof groups
    pub field_type: ::std::option::Option<NodeConfig_oneof_type>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeConfig {
    fn default() -> &'a NodeConfig {
        <NodeConfig as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum NodeConfig_oneof_type {
    oscillatorConfig(OscillatorNodeConfig),
    scriptingConfig(ScriptingNodeConfig),
    sequenceConfig(SequenceNodeConfig),
    clockConfig(ClockNodeConfig),
    fixtureConfig(FixtureNodeConfig),
    buttonConfig(InputNodeConfig),
    faderConfig(InputNodeConfig),
    ildaFileConfig(IldaFileNodeConfig),
    laserConfig(LaserNodeConfig),
    pixelPatternConfig(PixelPatternNodeConfig),
    pixelDmxConfig(PixelDmxNodeConfig),
    dmxOutputConfig(DmxOutputNodeConfig),
    midiInputConfig(MidiNodeConfig),
    midiOutputConfig(MidiNodeConfig),
    opcOutputConfig(OpcOutputNodeConfig),
    oscInputConfig(OscNodeConfig),
    oscOutputConfig(OscNodeConfig),
    videoColorBalanceConfig(VideoColorBalanceNodeConfig),
    videoEffectConfig(VideoEffectNodeConfig),
    videoFileConfig(VideoFileNodeConfig),
    videoOutputConfig(VideoOutputNodeConfig),
    videoTransformConfig(VideoTransformNodeConfig),
    selectConfig(SelectNodeConfig),
    mergeConfig(MergeNodeConfig),
    envelopeConfig(EnvelopeNodeConfig),
    sequencerConfig(SequencerNodeConfig),
    programmerConfig(ProgrammerNodeConfig),
    groupConfig(GroupNodeConfig),
    presetConfig(PresetNodeConfig),
    colorRgbConfig(ColorRgbNodeConfig),
    colorHsvConfig(ColorHsvNodeConfig),
    gamepadNodeConfig(GamepadNodeConfig),
    thresholdConfig(ThresholdNodeConfig),
}

impl NodeConfig {
    pub fn new() -> NodeConfig {
        ::std::default::Default::default()
    }

    // .mizer.OscillatorNodeConfig oscillatorConfig = 10;


    pub fn get_oscillatorConfig(&self) -> &OscillatorNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::oscillatorConfig(ref v)) => v,
            _ => <OscillatorNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_oscillatorConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_oscillatorConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::oscillatorConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_oscillatorConfig(&mut self, v: OscillatorNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::oscillatorConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_oscillatorConfig(&mut self) -> &mut OscillatorNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::oscillatorConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::oscillatorConfig(OscillatorNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::oscillatorConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_oscillatorConfig(&mut self) -> OscillatorNodeConfig {
        if self.has_oscillatorConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::oscillatorConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            OscillatorNodeConfig::new()
        }
    }

    // .mizer.ScriptingNodeConfig scriptingConfig = 11;


    pub fn get_scriptingConfig(&self) -> &ScriptingNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::scriptingConfig(ref v)) => v,
            _ => <ScriptingNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_scriptingConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_scriptingConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::scriptingConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_scriptingConfig(&mut self, v: ScriptingNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::scriptingConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_scriptingConfig(&mut self) -> &mut ScriptingNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::scriptingConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::scriptingConfig(ScriptingNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::scriptingConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_scriptingConfig(&mut self) -> ScriptingNodeConfig {
        if self.has_scriptingConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::scriptingConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ScriptingNodeConfig::new()
        }
    }

    // .mizer.SequenceNodeConfig sequenceConfig = 12;


    pub fn get_sequenceConfig(&self) -> &SequenceNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::sequenceConfig(ref v)) => v,
            _ => <SequenceNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_sequenceConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_sequenceConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::sequenceConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sequenceConfig(&mut self, v: SequenceNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::sequenceConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sequenceConfig(&mut self) -> &mut SequenceNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::sequenceConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::sequenceConfig(SequenceNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::sequenceConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sequenceConfig(&mut self) -> SequenceNodeConfig {
        if self.has_sequenceConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::sequenceConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            SequenceNodeConfig::new()
        }
    }

    // .mizer.ClockNodeConfig clockConfig = 13;


    pub fn get_clockConfig(&self) -> &ClockNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::clockConfig(ref v)) => v,
            _ => <ClockNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_clockConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_clockConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::clockConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_clockConfig(&mut self, v: ClockNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::clockConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_clockConfig(&mut self) -> &mut ClockNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::clockConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::clockConfig(ClockNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::clockConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_clockConfig(&mut self) -> ClockNodeConfig {
        if self.has_clockConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::clockConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ClockNodeConfig::new()
        }
    }

    // .mizer.FixtureNodeConfig fixtureConfig = 14;


    pub fn get_fixtureConfig(&self) -> &FixtureNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::fixtureConfig(ref v)) => v,
            _ => <FixtureNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_fixtureConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_fixtureConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::fixtureConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fixtureConfig(&mut self, v: FixtureNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::fixtureConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fixtureConfig(&mut self) -> &mut FixtureNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::fixtureConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::fixtureConfig(FixtureNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::fixtureConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fixtureConfig(&mut self) -> FixtureNodeConfig {
        if self.has_fixtureConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::fixtureConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            FixtureNodeConfig::new()
        }
    }

    // .mizer.InputNodeConfig buttonConfig = 15;


    pub fn get_buttonConfig(&self) -> &InputNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::buttonConfig(ref v)) => v,
            _ => <InputNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_buttonConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_buttonConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::buttonConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_buttonConfig(&mut self, v: InputNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::buttonConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_buttonConfig(&mut self) -> &mut InputNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::buttonConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::buttonConfig(InputNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::buttonConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_buttonConfig(&mut self) -> InputNodeConfig {
        if self.has_buttonConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::buttonConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            InputNodeConfig::new()
        }
    }

    // .mizer.InputNodeConfig faderConfig = 16;


    pub fn get_faderConfig(&self) -> &InputNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::faderConfig(ref v)) => v,
            _ => <InputNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_faderConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_faderConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::faderConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_faderConfig(&mut self, v: InputNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::faderConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_faderConfig(&mut self) -> &mut InputNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::faderConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::faderConfig(InputNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::faderConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_faderConfig(&mut self) -> InputNodeConfig {
        if self.has_faderConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::faderConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            InputNodeConfig::new()
        }
    }

    // .mizer.IldaFileNodeConfig ildaFileConfig = 17;


    pub fn get_ildaFileConfig(&self) -> &IldaFileNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::ildaFileConfig(ref v)) => v,
            _ => <IldaFileNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_ildaFileConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_ildaFileConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::ildaFileConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ildaFileConfig(&mut self, v: IldaFileNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::ildaFileConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ildaFileConfig(&mut self) -> &mut IldaFileNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::ildaFileConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::ildaFileConfig(IldaFileNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::ildaFileConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ildaFileConfig(&mut self) -> IldaFileNodeConfig {
        if self.has_ildaFileConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::ildaFileConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            IldaFileNodeConfig::new()
        }
    }

    // .mizer.LaserNodeConfig laserConfig = 18;


    pub fn get_laserConfig(&self) -> &LaserNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::laserConfig(ref v)) => v,
            _ => <LaserNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_laserConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_laserConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::laserConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_laserConfig(&mut self, v: LaserNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::laserConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_laserConfig(&mut self) -> &mut LaserNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::laserConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::laserConfig(LaserNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::laserConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_laserConfig(&mut self) -> LaserNodeConfig {
        if self.has_laserConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::laserConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            LaserNodeConfig::new()
        }
    }

    // .mizer.PixelPatternNodeConfig pixelPatternConfig = 19;


    pub fn get_pixelPatternConfig(&self) -> &PixelPatternNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::pixelPatternConfig(ref v)) => v,
            _ => <PixelPatternNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_pixelPatternConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_pixelPatternConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::pixelPatternConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pixelPatternConfig(&mut self, v: PixelPatternNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::pixelPatternConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pixelPatternConfig(&mut self) -> &mut PixelPatternNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::pixelPatternConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::pixelPatternConfig(PixelPatternNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::pixelPatternConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pixelPatternConfig(&mut self) -> PixelPatternNodeConfig {
        if self.has_pixelPatternConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::pixelPatternConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            PixelPatternNodeConfig::new()
        }
    }

    // .mizer.PixelDmxNodeConfig pixelDmxConfig = 20;


    pub fn get_pixelDmxConfig(&self) -> &PixelDmxNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::pixelDmxConfig(ref v)) => v,
            _ => <PixelDmxNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_pixelDmxConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_pixelDmxConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::pixelDmxConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pixelDmxConfig(&mut self, v: PixelDmxNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::pixelDmxConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pixelDmxConfig(&mut self) -> &mut PixelDmxNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::pixelDmxConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::pixelDmxConfig(PixelDmxNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::pixelDmxConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pixelDmxConfig(&mut self) -> PixelDmxNodeConfig {
        if self.has_pixelDmxConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::pixelDmxConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            PixelDmxNodeConfig::new()
        }
    }

    // .mizer.DmxOutputNodeConfig dmxOutputConfig = 21;


    pub fn get_dmxOutputConfig(&self) -> &DmxOutputNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::dmxOutputConfig(ref v)) => v,
            _ => <DmxOutputNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_dmxOutputConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_dmxOutputConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::dmxOutputConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dmxOutputConfig(&mut self, v: DmxOutputNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::dmxOutputConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dmxOutputConfig(&mut self) -> &mut DmxOutputNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::dmxOutputConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::dmxOutputConfig(DmxOutputNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::dmxOutputConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dmxOutputConfig(&mut self) -> DmxOutputNodeConfig {
        if self.has_dmxOutputConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::dmxOutputConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            DmxOutputNodeConfig::new()
        }
    }

    // .mizer.MidiNodeConfig midiInputConfig = 22;


    pub fn get_midiInputConfig(&self) -> &MidiNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::midiInputConfig(ref v)) => v,
            _ => <MidiNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_midiInputConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_midiInputConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::midiInputConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_midiInputConfig(&mut self, v: MidiNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::midiInputConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_midiInputConfig(&mut self) -> &mut MidiNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::midiInputConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::midiInputConfig(MidiNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::midiInputConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_midiInputConfig(&mut self) -> MidiNodeConfig {
        if self.has_midiInputConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::midiInputConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            MidiNodeConfig::new()
        }
    }

    // .mizer.MidiNodeConfig midiOutputConfig = 23;


    pub fn get_midiOutputConfig(&self) -> &MidiNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::midiOutputConfig(ref v)) => v,
            _ => <MidiNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_midiOutputConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_midiOutputConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::midiOutputConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_midiOutputConfig(&mut self, v: MidiNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::midiOutputConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_midiOutputConfig(&mut self) -> &mut MidiNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::midiOutputConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::midiOutputConfig(MidiNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::midiOutputConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_midiOutputConfig(&mut self) -> MidiNodeConfig {
        if self.has_midiOutputConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::midiOutputConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            MidiNodeConfig::new()
        }
    }

    // .mizer.OpcOutputNodeConfig opcOutputConfig = 24;


    pub fn get_opcOutputConfig(&self) -> &OpcOutputNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::opcOutputConfig(ref v)) => v,
            _ => <OpcOutputNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_opcOutputConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_opcOutputConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::opcOutputConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_opcOutputConfig(&mut self, v: OpcOutputNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::opcOutputConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_opcOutputConfig(&mut self) -> &mut OpcOutputNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::opcOutputConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::opcOutputConfig(OpcOutputNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::opcOutputConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_opcOutputConfig(&mut self) -> OpcOutputNodeConfig {
        if self.has_opcOutputConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::opcOutputConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            OpcOutputNodeConfig::new()
        }
    }

    // .mizer.OscNodeConfig oscInputConfig = 25;


    pub fn get_oscInputConfig(&self) -> &OscNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::oscInputConfig(ref v)) => v,
            _ => <OscNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_oscInputConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_oscInputConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::oscInputConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_oscInputConfig(&mut self, v: OscNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::oscInputConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_oscInputConfig(&mut self) -> &mut OscNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::oscInputConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::oscInputConfig(OscNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::oscInputConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_oscInputConfig(&mut self) -> OscNodeConfig {
        if self.has_oscInputConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::oscInputConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            OscNodeConfig::new()
        }
    }

    // .mizer.OscNodeConfig oscOutputConfig = 26;


    pub fn get_oscOutputConfig(&self) -> &OscNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::oscOutputConfig(ref v)) => v,
            _ => <OscNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_oscOutputConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_oscOutputConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::oscOutputConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_oscOutputConfig(&mut self, v: OscNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::oscOutputConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_oscOutputConfig(&mut self) -> &mut OscNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::oscOutputConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::oscOutputConfig(OscNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::oscOutputConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_oscOutputConfig(&mut self) -> OscNodeConfig {
        if self.has_oscOutputConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::oscOutputConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            OscNodeConfig::new()
        }
    }

    // .mizer.VideoColorBalanceNodeConfig videoColorBalanceConfig = 27;


    pub fn get_videoColorBalanceConfig(&self) -> &VideoColorBalanceNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::videoColorBalanceConfig(ref v)) => v,
            _ => <VideoColorBalanceNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_videoColorBalanceConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_videoColorBalanceConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::videoColorBalanceConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_videoColorBalanceConfig(&mut self, v: VideoColorBalanceNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::videoColorBalanceConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_videoColorBalanceConfig(&mut self) -> &mut VideoColorBalanceNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::videoColorBalanceConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::videoColorBalanceConfig(VideoColorBalanceNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::videoColorBalanceConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_videoColorBalanceConfig(&mut self) -> VideoColorBalanceNodeConfig {
        if self.has_videoColorBalanceConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::videoColorBalanceConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            VideoColorBalanceNodeConfig::new()
        }
    }

    // .mizer.VideoEffectNodeConfig videoEffectConfig = 28;


    pub fn get_videoEffectConfig(&self) -> &VideoEffectNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::videoEffectConfig(ref v)) => v,
            _ => <VideoEffectNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_videoEffectConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_videoEffectConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::videoEffectConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_videoEffectConfig(&mut self, v: VideoEffectNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::videoEffectConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_videoEffectConfig(&mut self) -> &mut VideoEffectNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::videoEffectConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::videoEffectConfig(VideoEffectNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::videoEffectConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_videoEffectConfig(&mut self) -> VideoEffectNodeConfig {
        if self.has_videoEffectConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::videoEffectConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            VideoEffectNodeConfig::new()
        }
    }

    // .mizer.VideoFileNodeConfig videoFileConfig = 29;


    pub fn get_videoFileConfig(&self) -> &VideoFileNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::videoFileConfig(ref v)) => v,
            _ => <VideoFileNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_videoFileConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_videoFileConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::videoFileConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_videoFileConfig(&mut self, v: VideoFileNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::videoFileConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_videoFileConfig(&mut self) -> &mut VideoFileNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::videoFileConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::videoFileConfig(VideoFileNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::videoFileConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_videoFileConfig(&mut self) -> VideoFileNodeConfig {
        if self.has_videoFileConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::videoFileConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            VideoFileNodeConfig::new()
        }
    }

    // .mizer.VideoOutputNodeConfig videoOutputConfig = 30;


    pub fn get_videoOutputConfig(&self) -> &VideoOutputNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::videoOutputConfig(ref v)) => v,
            _ => <VideoOutputNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_videoOutputConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_videoOutputConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::videoOutputConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_videoOutputConfig(&mut self, v: VideoOutputNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::videoOutputConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_videoOutputConfig(&mut self) -> &mut VideoOutputNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::videoOutputConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::videoOutputConfig(VideoOutputNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::videoOutputConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_videoOutputConfig(&mut self) -> VideoOutputNodeConfig {
        if self.has_videoOutputConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::videoOutputConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            VideoOutputNodeConfig::new()
        }
    }

    // .mizer.VideoTransformNodeConfig videoTransformConfig = 31;


    pub fn get_videoTransformConfig(&self) -> &VideoTransformNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::videoTransformConfig(ref v)) => v,
            _ => <VideoTransformNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_videoTransformConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_videoTransformConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::videoTransformConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_videoTransformConfig(&mut self, v: VideoTransformNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::videoTransformConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_videoTransformConfig(&mut self) -> &mut VideoTransformNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::videoTransformConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::videoTransformConfig(VideoTransformNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::videoTransformConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_videoTransformConfig(&mut self) -> VideoTransformNodeConfig {
        if self.has_videoTransformConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::videoTransformConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            VideoTransformNodeConfig::new()
        }
    }

    // .mizer.SelectNodeConfig selectConfig = 32;


    pub fn get_selectConfig(&self) -> &SelectNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::selectConfig(ref v)) => v,
            _ => <SelectNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_selectConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_selectConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::selectConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_selectConfig(&mut self, v: SelectNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::selectConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_selectConfig(&mut self) -> &mut SelectNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::selectConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::selectConfig(SelectNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::selectConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_selectConfig(&mut self) -> SelectNodeConfig {
        if self.has_selectConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::selectConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            SelectNodeConfig::new()
        }
    }

    // .mizer.MergeNodeConfig mergeConfig = 33;


    pub fn get_mergeConfig(&self) -> &MergeNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::mergeConfig(ref v)) => v,
            _ => <MergeNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_mergeConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_mergeConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::mergeConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mergeConfig(&mut self, v: MergeNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::mergeConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mergeConfig(&mut self) -> &mut MergeNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::mergeConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::mergeConfig(MergeNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::mergeConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mergeConfig(&mut self) -> MergeNodeConfig {
        if self.has_mergeConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::mergeConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            MergeNodeConfig::new()
        }
    }

    // .mizer.EnvelopeNodeConfig envelopeConfig = 34;


    pub fn get_envelopeConfig(&self) -> &EnvelopeNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::envelopeConfig(ref v)) => v,
            _ => <EnvelopeNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_envelopeConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_envelopeConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::envelopeConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_envelopeConfig(&mut self, v: EnvelopeNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::envelopeConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_envelopeConfig(&mut self) -> &mut EnvelopeNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::envelopeConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::envelopeConfig(EnvelopeNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::envelopeConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_envelopeConfig(&mut self) -> EnvelopeNodeConfig {
        if self.has_envelopeConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::envelopeConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            EnvelopeNodeConfig::new()
        }
    }

    // .mizer.SequencerNodeConfig sequencerConfig = 35;


    pub fn get_sequencerConfig(&self) -> &SequencerNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::sequencerConfig(ref v)) => v,
            _ => <SequencerNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_sequencerConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_sequencerConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::sequencerConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sequencerConfig(&mut self, v: SequencerNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::sequencerConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sequencerConfig(&mut self) -> &mut SequencerNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::sequencerConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::sequencerConfig(SequencerNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::sequencerConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sequencerConfig(&mut self) -> SequencerNodeConfig {
        if self.has_sequencerConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::sequencerConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            SequencerNodeConfig::new()
        }
    }

    // .mizer.ProgrammerNodeConfig programmerConfig = 36;


    pub fn get_programmerConfig(&self) -> &ProgrammerNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::programmerConfig(ref v)) => v,
            _ => <ProgrammerNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_programmerConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_programmerConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::programmerConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_programmerConfig(&mut self, v: ProgrammerNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::programmerConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_programmerConfig(&mut self) -> &mut ProgrammerNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::programmerConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::programmerConfig(ProgrammerNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::programmerConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_programmerConfig(&mut self) -> ProgrammerNodeConfig {
        if self.has_programmerConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::programmerConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ProgrammerNodeConfig::new()
        }
    }

    // .mizer.GroupNodeConfig groupConfig = 37;


    pub fn get_groupConfig(&self) -> &GroupNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::groupConfig(ref v)) => v,
            _ => <GroupNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_groupConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_groupConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::groupConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_groupConfig(&mut self, v: GroupNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::groupConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_groupConfig(&mut self) -> &mut GroupNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::groupConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::groupConfig(GroupNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::groupConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_groupConfig(&mut self) -> GroupNodeConfig {
        if self.has_groupConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::groupConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            GroupNodeConfig::new()
        }
    }

    // .mizer.PresetNodeConfig presetConfig = 38;


    pub fn get_presetConfig(&self) -> &PresetNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::presetConfig(ref v)) => v,
            _ => <PresetNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_presetConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_presetConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::presetConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_presetConfig(&mut self, v: PresetNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::presetConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_presetConfig(&mut self) -> &mut PresetNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::presetConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::presetConfig(PresetNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::presetConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_presetConfig(&mut self) -> PresetNodeConfig {
        if self.has_presetConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::presetConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            PresetNodeConfig::new()
        }
    }

    // .mizer.ColorRgbNodeConfig colorRgbConfig = 40;


    pub fn get_colorRgbConfig(&self) -> &ColorRgbNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::colorRgbConfig(ref v)) => v,
            _ => <ColorRgbNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_colorRgbConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_colorRgbConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::colorRgbConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_colorRgbConfig(&mut self, v: ColorRgbNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::colorRgbConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_colorRgbConfig(&mut self) -> &mut ColorRgbNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::colorRgbConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::colorRgbConfig(ColorRgbNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::colorRgbConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_colorRgbConfig(&mut self) -> ColorRgbNodeConfig {
        if self.has_colorRgbConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::colorRgbConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ColorRgbNodeConfig::new()
        }
    }

    // .mizer.ColorHsvNodeConfig colorHsvConfig = 41;


    pub fn get_colorHsvConfig(&self) -> &ColorHsvNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::colorHsvConfig(ref v)) => v,
            _ => <ColorHsvNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_colorHsvConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_colorHsvConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::colorHsvConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_colorHsvConfig(&mut self, v: ColorHsvNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::colorHsvConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_colorHsvConfig(&mut self) -> &mut ColorHsvNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::colorHsvConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::colorHsvConfig(ColorHsvNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::colorHsvConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_colorHsvConfig(&mut self) -> ColorHsvNodeConfig {
        if self.has_colorHsvConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::colorHsvConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ColorHsvNodeConfig::new()
        }
    }

    // .mizer.GamepadNodeConfig gamepadNodeConfig = 42;


    pub fn get_gamepadNodeConfig(&self) -> &GamepadNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::gamepadNodeConfig(ref v)) => v,
            _ => <GamepadNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_gamepadNodeConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_gamepadNodeConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::gamepadNodeConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gamepadNodeConfig(&mut self, v: GamepadNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::gamepadNodeConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gamepadNodeConfig(&mut self) -> &mut GamepadNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::gamepadNodeConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::gamepadNodeConfig(GamepadNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::gamepadNodeConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gamepadNodeConfig(&mut self) -> GamepadNodeConfig {
        if self.has_gamepadNodeConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::gamepadNodeConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            GamepadNodeConfig::new()
        }
    }

    // .mizer.ThresholdNodeConfig thresholdConfig = 43;


    pub fn get_thresholdConfig(&self) -> &ThresholdNodeConfig {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::thresholdConfig(ref v)) => v,
            _ => <ThresholdNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_thresholdConfig(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_thresholdConfig(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::thresholdConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thresholdConfig(&mut self, v: ThresholdNodeConfig) {
        self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::thresholdConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thresholdConfig(&mut self) -> &mut ThresholdNodeConfig {
        if let ::std::option::Option::Some(NodeConfig_oneof_type::thresholdConfig(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::thresholdConfig(ThresholdNodeConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(NodeConfig_oneof_type::thresholdConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thresholdConfig(&mut self) -> ThresholdNodeConfig {
        if self.has_thresholdConfig() {
            match self.field_type.take() {
                ::std::option::Option::Some(NodeConfig_oneof_type::thresholdConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ThresholdNodeConfig::new()
        }
    }
}

impl ::protobuf::Message for NodeConfig {
    fn is_initialized(&self) -> bool {
        if let Some(NodeConfig_oneof_type::oscillatorConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::scriptingConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::sequenceConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::clockConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::fixtureConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::buttonConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::faderConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::ildaFileConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::laserConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::pixelPatternConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::pixelDmxConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::dmxOutputConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::midiInputConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::midiOutputConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::opcOutputConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::oscInputConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::oscOutputConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::videoColorBalanceConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::videoEffectConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::videoFileConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::videoOutputConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::videoTransformConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::selectConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::mergeConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::envelopeConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::sequencerConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::programmerConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::groupConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::presetConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::colorRgbConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::colorHsvConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::gamepadNodeConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(NodeConfig_oneof_type::thresholdConfig(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::oscillatorConfig(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::scriptingConfig(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::sequenceConfig(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::clockConfig(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::fixtureConfig(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::buttonConfig(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::faderConfig(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::ildaFileConfig(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::laserConfig(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::pixelPatternConfig(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::pixelDmxConfig(is.read_message()?));
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::dmxOutputConfig(is.read_message()?));
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::midiInputConfig(is.read_message()?));
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::midiOutputConfig(is.read_message()?));
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::opcOutputConfig(is.read_message()?));
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::oscInputConfig(is.read_message()?));
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::oscOutputConfig(is.read_message()?));
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::videoColorBalanceConfig(is.read_message()?));
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::videoEffectConfig(is.read_message()?));
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::videoFileConfig(is.read_message()?));
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::videoOutputConfig(is.read_message()?));
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::videoTransformConfig(is.read_message()?));
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::selectConfig(is.read_message()?));
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::mergeConfig(is.read_message()?));
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::envelopeConfig(is.read_message()?));
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::sequencerConfig(is.read_message()?));
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::programmerConfig(is.read_message()?));
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::groupConfig(is.read_message()?));
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::presetConfig(is.read_message()?));
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::colorRgbConfig(is.read_message()?));
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::colorHsvConfig(is.read_message()?));
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::gamepadNodeConfig(is.read_message()?));
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(NodeConfig_oneof_type::thresholdConfig(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &NodeConfig_oneof_type::oscillatorConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::scriptingConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::sequenceConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::clockConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::fixtureConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::buttonConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::faderConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::ildaFileConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::laserConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::pixelPatternConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::pixelDmxConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::dmxOutputConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::midiInputConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::midiOutputConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::opcOutputConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::oscInputConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::oscOutputConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::videoColorBalanceConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::videoEffectConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::videoFileConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::videoOutputConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::videoTransformConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::selectConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::mergeConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::envelopeConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::sequencerConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::programmerConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::groupConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::presetConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::colorRgbConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::colorHsvConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::gamepadNodeConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &NodeConfig_oneof_type::thresholdConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &NodeConfig_oneof_type::oscillatorConfig(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::scriptingConfig(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::sequenceConfig(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::clockConfig(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::fixtureConfig(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::buttonConfig(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::faderConfig(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::ildaFileConfig(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::laserConfig(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::pixelPatternConfig(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::pixelDmxConfig(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::dmxOutputConfig(ref v) => {
                    os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::midiInputConfig(ref v) => {
                    os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::midiOutputConfig(ref v) => {
                    os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::opcOutputConfig(ref v) => {
                    os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::oscInputConfig(ref v) => {
                    os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::oscOutputConfig(ref v) => {
                    os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::videoColorBalanceConfig(ref v) => {
                    os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::videoEffectConfig(ref v) => {
                    os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::videoFileConfig(ref v) => {
                    os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::videoOutputConfig(ref v) => {
                    os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::videoTransformConfig(ref v) => {
                    os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::selectConfig(ref v) => {
                    os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::mergeConfig(ref v) => {
                    os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::envelopeConfig(ref v) => {
                    os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::sequencerConfig(ref v) => {
                    os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::programmerConfig(ref v) => {
                    os.write_tag(36, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::groupConfig(ref v) => {
                    os.write_tag(37, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::presetConfig(ref v) => {
                    os.write_tag(38, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::colorRgbConfig(ref v) => {
                    os.write_tag(40, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::colorHsvConfig(ref v) => {
                    os.write_tag(41, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::gamepadNodeConfig(ref v) => {
                    os.write_tag(42, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &NodeConfig_oneof_type::thresholdConfig(ref v) => {
                    os.write_tag(43, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeConfig {
        NodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OscillatorNodeConfig>(
                "oscillatorConfig",
                NodeConfig::has_oscillatorConfig,
                NodeConfig::get_oscillatorConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ScriptingNodeConfig>(
                "scriptingConfig",
                NodeConfig::has_scriptingConfig,
                NodeConfig::get_scriptingConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SequenceNodeConfig>(
                "sequenceConfig",
                NodeConfig::has_sequenceConfig,
                NodeConfig::get_sequenceConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ClockNodeConfig>(
                "clockConfig",
                NodeConfig::has_clockConfig,
                NodeConfig::get_clockConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FixtureNodeConfig>(
                "fixtureConfig",
                NodeConfig::has_fixtureConfig,
                NodeConfig::get_fixtureConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, InputNodeConfig>(
                "buttonConfig",
                NodeConfig::has_buttonConfig,
                NodeConfig::get_buttonConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, InputNodeConfig>(
                "faderConfig",
                NodeConfig::has_faderConfig,
                NodeConfig::get_faderConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, IldaFileNodeConfig>(
                "ildaFileConfig",
                NodeConfig::has_ildaFileConfig,
                NodeConfig::get_ildaFileConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, LaserNodeConfig>(
                "laserConfig",
                NodeConfig::has_laserConfig,
                NodeConfig::get_laserConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PixelPatternNodeConfig>(
                "pixelPatternConfig",
                NodeConfig::has_pixelPatternConfig,
                NodeConfig::get_pixelPatternConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PixelDmxNodeConfig>(
                "pixelDmxConfig",
                NodeConfig::has_pixelDmxConfig,
                NodeConfig::get_pixelDmxConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DmxOutputNodeConfig>(
                "dmxOutputConfig",
                NodeConfig::has_dmxOutputConfig,
                NodeConfig::get_dmxOutputConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MidiNodeConfig>(
                "midiInputConfig",
                NodeConfig::has_midiInputConfig,
                NodeConfig::get_midiInputConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MidiNodeConfig>(
                "midiOutputConfig",
                NodeConfig::has_midiOutputConfig,
                NodeConfig::get_midiOutputConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OpcOutputNodeConfig>(
                "opcOutputConfig",
                NodeConfig::has_opcOutputConfig,
                NodeConfig::get_opcOutputConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OscNodeConfig>(
                "oscInputConfig",
                NodeConfig::has_oscInputConfig,
                NodeConfig::get_oscInputConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OscNodeConfig>(
                "oscOutputConfig",
                NodeConfig::has_oscOutputConfig,
                NodeConfig::get_oscOutputConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VideoColorBalanceNodeConfig>(
                "videoColorBalanceConfig",
                NodeConfig::has_videoColorBalanceConfig,
                NodeConfig::get_videoColorBalanceConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VideoEffectNodeConfig>(
                "videoEffectConfig",
                NodeConfig::has_videoEffectConfig,
                NodeConfig::get_videoEffectConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VideoFileNodeConfig>(
                "videoFileConfig",
                NodeConfig::has_videoFileConfig,
                NodeConfig::get_videoFileConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VideoOutputNodeConfig>(
                "videoOutputConfig",
                NodeConfig::has_videoOutputConfig,
                NodeConfig::get_videoOutputConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VideoTransformNodeConfig>(
                "videoTransformConfig",
                NodeConfig::has_videoTransformConfig,
                NodeConfig::get_videoTransformConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SelectNodeConfig>(
                "selectConfig",
                NodeConfig::has_selectConfig,
                NodeConfig::get_selectConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MergeNodeConfig>(
                "mergeConfig",
                NodeConfig::has_mergeConfig,
                NodeConfig::get_mergeConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EnvelopeNodeConfig>(
                "envelopeConfig",
                NodeConfig::has_envelopeConfig,
                NodeConfig::get_envelopeConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SequencerNodeConfig>(
                "sequencerConfig",
                NodeConfig::has_sequencerConfig,
                NodeConfig::get_sequencerConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ProgrammerNodeConfig>(
                "programmerConfig",
                NodeConfig::has_programmerConfig,
                NodeConfig::get_programmerConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GroupNodeConfig>(
                "groupConfig",
                NodeConfig::has_groupConfig,
                NodeConfig::get_groupConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PresetNodeConfig>(
                "presetConfig",
                NodeConfig::has_presetConfig,
                NodeConfig::get_presetConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ColorRgbNodeConfig>(
                "colorRgbConfig",
                NodeConfig::has_colorRgbConfig,
                NodeConfig::get_colorRgbConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ColorHsvNodeConfig>(
                "colorHsvConfig",
                NodeConfig::has_colorHsvConfig,
                NodeConfig::get_colorHsvConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GamepadNodeConfig>(
                "gamepadNodeConfig",
                NodeConfig::has_gamepadNodeConfig,
                NodeConfig::get_gamepadNodeConfig,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThresholdNodeConfig>(
                "thresholdConfig",
                NodeConfig::has_thresholdConfig,
                NodeConfig::get_thresholdConfig,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeConfig>(
                "NodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeConfig {
        static instance: ::protobuf::rt::LazyV2<NodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeConfig::new)
    }
}

impl ::protobuf::Clear for NodeConfig {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct OscillatorNodeConfig {
    // message fields
    pub field_type: OscillatorNodeConfig_OscillatorType,
    pub ratio: f64,
    pub max: f64,
    pub min: f64,
    pub offset: f64,
    pub reverse: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OscillatorNodeConfig {
    fn default() -> &'a OscillatorNodeConfig {
        <OscillatorNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl OscillatorNodeConfig {
    pub fn new() -> OscillatorNodeConfig {
        ::std::default::Default::default()
    }

    // .mizer.OscillatorNodeConfig.OscillatorType type = 1;


    pub fn get_field_type(&self) -> OscillatorNodeConfig_OscillatorType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = OscillatorNodeConfig_OscillatorType::Square;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: OscillatorNodeConfig_OscillatorType) {
        self.field_type = v;
    }

    // double ratio = 2;


    pub fn get_ratio(&self) -> f64 {
        self.ratio
    }
    pub fn clear_ratio(&mut self) {
        self.ratio = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ratio(&mut self, v: f64) {
        self.ratio = v;
    }

    // double max = 3;


    pub fn get_max(&self) -> f64 {
        self.max
    }
    pub fn clear_max(&mut self) {
        self.max = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: f64) {
        self.max = v;
    }

    // double min = 4;


    pub fn get_min(&self) -> f64 {
        self.min
    }
    pub fn clear_min(&mut self) {
        self.min = 0.;
    }

    // Param is passed by value, moved
    pub fn set_min(&mut self, v: f64) {
        self.min = v;
    }

    // double offset = 5;


    pub fn get_offset(&self) -> f64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0.;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: f64) {
        self.offset = v;
    }

    // bool reverse = 6;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }
}

impl ::protobuf::Message for OscillatorNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.ratio = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.max = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.min = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.offset = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != OscillatorNodeConfig_OscillatorType::Square {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if self.ratio != 0. {
            my_size += 9;
        }
        if self.max != 0. {
            my_size += 9;
        }
        if self.min != 0. {
            my_size += 9;
        }
        if self.offset != 0. {
            my_size += 9;
        }
        if self.reverse != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != OscillatorNodeConfig_OscillatorType::Square {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.ratio != 0. {
            os.write_double(2, self.ratio)?;
        }
        if self.max != 0. {
            os.write_double(3, self.max)?;
        }
        if self.min != 0. {
            os.write_double(4, self.min)?;
        }
        if self.offset != 0. {
            os.write_double(5, self.offset)?;
        }
        if self.reverse != false {
            os.write_bool(6, self.reverse)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OscillatorNodeConfig {
        OscillatorNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OscillatorNodeConfig_OscillatorType>>(
                "type",
                |m: &OscillatorNodeConfig| { &m.field_type },
                |m: &mut OscillatorNodeConfig| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "ratio",
                |m: &OscillatorNodeConfig| { &m.ratio },
                |m: &mut OscillatorNodeConfig| { &mut m.ratio },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "max",
                |m: &OscillatorNodeConfig| { &m.max },
                |m: &mut OscillatorNodeConfig| { &mut m.max },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "min",
                |m: &OscillatorNodeConfig| { &m.min },
                |m: &mut OscillatorNodeConfig| { &mut m.min },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "offset",
                |m: &OscillatorNodeConfig| { &m.offset },
                |m: &mut OscillatorNodeConfig| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reverse",
                |m: &OscillatorNodeConfig| { &m.reverse },
                |m: &mut OscillatorNodeConfig| { &mut m.reverse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OscillatorNodeConfig>(
                "OscillatorNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OscillatorNodeConfig {
        static instance: ::protobuf::rt::LazyV2<OscillatorNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OscillatorNodeConfig::new)
    }
}

impl ::protobuf::Clear for OscillatorNodeConfig {
    fn clear(&mut self) {
        self.field_type = OscillatorNodeConfig_OscillatorType::Square;
        self.ratio = 0.;
        self.max = 0.;
        self.min = 0.;
        self.offset = 0.;
        self.reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OscillatorNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OscillatorNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum OscillatorNodeConfig_OscillatorType {
    Square = 0,
    Sine = 1,
    Saw = 2,
    Triangle = 3,
}

impl ::protobuf::ProtobufEnum for OscillatorNodeConfig_OscillatorType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OscillatorNodeConfig_OscillatorType> {
        match value {
            0 => ::std::option::Option::Some(OscillatorNodeConfig_OscillatorType::Square),
            1 => ::std::option::Option::Some(OscillatorNodeConfig_OscillatorType::Sine),
            2 => ::std::option::Option::Some(OscillatorNodeConfig_OscillatorType::Saw),
            3 => ::std::option::Option::Some(OscillatorNodeConfig_OscillatorType::Triangle),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OscillatorNodeConfig_OscillatorType] = &[
            OscillatorNodeConfig_OscillatorType::Square,
            OscillatorNodeConfig_OscillatorType::Sine,
            OscillatorNodeConfig_OscillatorType::Saw,
            OscillatorNodeConfig_OscillatorType::Triangle,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OscillatorNodeConfig_OscillatorType>("OscillatorNodeConfig.OscillatorType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OscillatorNodeConfig_OscillatorType {
}

impl ::std::default::Default for OscillatorNodeConfig_OscillatorType {
    fn default() -> Self {
        OscillatorNodeConfig_OscillatorType::Square
    }
}

impl ::protobuf::reflect::ProtobufValue for OscillatorNodeConfig_OscillatorType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ScriptingNodeConfig {
    // message fields
    pub script: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScriptingNodeConfig {
    fn default() -> &'a ScriptingNodeConfig {
        <ScriptingNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl ScriptingNodeConfig {
    pub fn new() -> ScriptingNodeConfig {
        ::std::default::Default::default()
    }

    // string script = 1;


    pub fn get_script(&self) -> &str {
        &self.script
    }
    pub fn clear_script(&mut self) {
        self.script.clear();
    }

    // Param is passed by value, moved
    pub fn set_script(&mut self, v: ::std::string::String) {
        self.script = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_script(&mut self) -> &mut ::std::string::String {
        &mut self.script
    }

    // Take field
    pub fn take_script(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.script, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ScriptingNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.script)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.script.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.script);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.script.is_empty() {
            os.write_string(1, &self.script)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScriptingNodeConfig {
        ScriptingNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "script",
                |m: &ScriptingNodeConfig| { &m.script },
                |m: &mut ScriptingNodeConfig| { &mut m.script },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScriptingNodeConfig>(
                "ScriptingNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScriptingNodeConfig {
        static instance: ::protobuf::rt::LazyV2<ScriptingNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScriptingNodeConfig::new)
    }
}

impl ::protobuf::Clear for ScriptingNodeConfig {
    fn clear(&mut self) {
        self.script.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScriptingNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScriptingNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SequenceNodeConfig {
    // message fields
    pub steps: ::protobuf::RepeatedField<SequenceNodeConfig_SequenceStep>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SequenceNodeConfig {
    fn default() -> &'a SequenceNodeConfig {
        <SequenceNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl SequenceNodeConfig {
    pub fn new() -> SequenceNodeConfig {
        ::std::default::Default::default()
    }

    // repeated .mizer.SequenceNodeConfig.SequenceStep steps = 1;


    pub fn get_steps(&self) -> &[SequenceNodeConfig_SequenceStep] {
        &self.steps
    }
    pub fn clear_steps(&mut self) {
        self.steps.clear();
    }

    // Param is passed by value, moved
    pub fn set_steps(&mut self, v: ::protobuf::RepeatedField<SequenceNodeConfig_SequenceStep>) {
        self.steps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steps(&mut self) -> &mut ::protobuf::RepeatedField<SequenceNodeConfig_SequenceStep> {
        &mut self.steps
    }

    // Take field
    pub fn take_steps(&mut self) -> ::protobuf::RepeatedField<SequenceNodeConfig_SequenceStep> {
        ::std::mem::replace(&mut self.steps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SequenceNodeConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.steps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.steps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.steps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.steps {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SequenceNodeConfig {
        SequenceNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SequenceNodeConfig_SequenceStep>>(
                "steps",
                |m: &SequenceNodeConfig| { &m.steps },
                |m: &mut SequenceNodeConfig| { &mut m.steps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SequenceNodeConfig>(
                "SequenceNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SequenceNodeConfig {
        static instance: ::protobuf::rt::LazyV2<SequenceNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SequenceNodeConfig::new)
    }
}

impl ::protobuf::Clear for SequenceNodeConfig {
    fn clear(&mut self) {
        self.steps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SequenceNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SequenceNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SequenceNodeConfig_SequenceStep {
    // message fields
    pub tick: f64,
    pub value: f64,
    pub hold: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SequenceNodeConfig_SequenceStep {
    fn default() -> &'a SequenceNodeConfig_SequenceStep {
        <SequenceNodeConfig_SequenceStep as ::protobuf::Message>::default_instance()
    }
}

impl SequenceNodeConfig_SequenceStep {
    pub fn new() -> SequenceNodeConfig_SequenceStep {
        ::std::default::Default::default()
    }

    // double tick = 1;


    pub fn get_tick(&self) -> f64 {
        self.tick
    }
    pub fn clear_tick(&mut self) {
        self.tick = 0.;
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: f64) {
        self.tick = v;
    }

    // double value = 2;


    pub fn get_value(&self) -> f64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f64) {
        self.value = v;
    }

    // bool hold = 3;


    pub fn get_hold(&self) -> bool {
        self.hold
    }
    pub fn clear_hold(&mut self) {
        self.hold = false;
    }

    // Param is passed by value, moved
    pub fn set_hold(&mut self, v: bool) {
        self.hold = v;
    }
}

impl ::protobuf::Message for SequenceNodeConfig_SequenceStep {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.tick = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.value = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hold = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tick != 0. {
            my_size += 9;
        }
        if self.value != 0. {
            my_size += 9;
        }
        if self.hold != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.tick != 0. {
            os.write_double(1, self.tick)?;
        }
        if self.value != 0. {
            os.write_double(2, self.value)?;
        }
        if self.hold != false {
            os.write_bool(3, self.hold)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SequenceNodeConfig_SequenceStep {
        SequenceNodeConfig_SequenceStep::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "tick",
                |m: &SequenceNodeConfig_SequenceStep| { &m.tick },
                |m: &mut SequenceNodeConfig_SequenceStep| { &mut m.tick },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "value",
                |m: &SequenceNodeConfig_SequenceStep| { &m.value },
                |m: &mut SequenceNodeConfig_SequenceStep| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hold",
                |m: &SequenceNodeConfig_SequenceStep| { &m.hold },
                |m: &mut SequenceNodeConfig_SequenceStep| { &mut m.hold },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SequenceNodeConfig_SequenceStep>(
                "SequenceNodeConfig.SequenceStep",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SequenceNodeConfig_SequenceStep {
        static instance: ::protobuf::rt::LazyV2<SequenceNodeConfig_SequenceStep> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SequenceNodeConfig_SequenceStep::new)
    }
}

impl ::protobuf::Clear for SequenceNodeConfig_SequenceStep {
    fn clear(&mut self) {
        self.tick = 0.;
        self.value = 0.;
        self.hold = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SequenceNodeConfig_SequenceStep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SequenceNodeConfig_SequenceStep {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ProgrammerNodeConfig {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProgrammerNodeConfig {
    fn default() -> &'a ProgrammerNodeConfig {
        <ProgrammerNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl ProgrammerNodeConfig {
    pub fn new() -> ProgrammerNodeConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ProgrammerNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProgrammerNodeConfig {
        ProgrammerNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProgrammerNodeConfig>(
                "ProgrammerNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProgrammerNodeConfig {
        static instance: ::protobuf::rt::LazyV2<ProgrammerNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProgrammerNodeConfig::new)
    }
}

impl ::protobuf::Clear for ProgrammerNodeConfig {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProgrammerNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProgrammerNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupNodeConfig {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupNodeConfig {
    fn default() -> &'a GroupNodeConfig {
        <GroupNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl GroupNodeConfig {
    pub fn new() -> GroupNodeConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GroupNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupNodeConfig {
        GroupNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupNodeConfig>(
                "GroupNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupNodeConfig {
        static instance: ::protobuf::rt::LazyV2<GroupNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupNodeConfig::new)
    }
}

impl ::protobuf::Clear for GroupNodeConfig {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PresetNodeConfig {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PresetNodeConfig {
    fn default() -> &'a PresetNodeConfig {
        <PresetNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl PresetNodeConfig {
    pub fn new() -> PresetNodeConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PresetNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PresetNodeConfig {
        PresetNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PresetNodeConfig>(
                "PresetNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PresetNodeConfig {
        static instance: ::protobuf::rt::LazyV2<PresetNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PresetNodeConfig::new)
    }
}

impl ::protobuf::Clear for PresetNodeConfig {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PresetNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PresetNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct EnvelopeNodeConfig {
    // message fields
    pub attack: f64,
    pub decay: f64,
    pub sustain: f64,
    pub release: f64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnvelopeNodeConfig {
    fn default() -> &'a EnvelopeNodeConfig {
        <EnvelopeNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl EnvelopeNodeConfig {
    pub fn new() -> EnvelopeNodeConfig {
        ::std::default::Default::default()
    }

    // double attack = 1;


    pub fn get_attack(&self) -> f64 {
        self.attack
    }
    pub fn clear_attack(&mut self) {
        self.attack = 0.;
    }

    // Param is passed by value, moved
    pub fn set_attack(&mut self, v: f64) {
        self.attack = v;
    }

    // double decay = 2;


    pub fn get_decay(&self) -> f64 {
        self.decay
    }
    pub fn clear_decay(&mut self) {
        self.decay = 0.;
    }

    // Param is passed by value, moved
    pub fn set_decay(&mut self, v: f64) {
        self.decay = v;
    }

    // double sustain = 3;


    pub fn get_sustain(&self) -> f64 {
        self.sustain
    }
    pub fn clear_sustain(&mut self) {
        self.sustain = 0.;
    }

    // Param is passed by value, moved
    pub fn set_sustain(&mut self, v: f64) {
        self.sustain = v;
    }

    // double release = 4;


    pub fn get_release(&self) -> f64 {
        self.release
    }
    pub fn clear_release(&mut self) {
        self.release = 0.;
    }

    // Param is passed by value, moved
    pub fn set_release(&mut self, v: f64) {
        self.release = v;
    }
}

impl ::protobuf::Message for EnvelopeNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.attack = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.decay = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.sustain = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.release = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.attack != 0. {
            my_size += 9;
        }
        if self.decay != 0. {
            my_size += 9;
        }
        if self.sustain != 0. {
            my_size += 9;
        }
        if self.release != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.attack != 0. {
            os.write_double(1, self.attack)?;
        }
        if self.decay != 0. {
            os.write_double(2, self.decay)?;
        }
        if self.sustain != 0. {
            os.write_double(3, self.sustain)?;
        }
        if self.release != 0. {
            os.write_double(4, self.release)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnvelopeNodeConfig {
        EnvelopeNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "attack",
                |m: &EnvelopeNodeConfig| { &m.attack },
                |m: &mut EnvelopeNodeConfig| { &mut m.attack },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "decay",
                |m: &EnvelopeNodeConfig| { &m.decay },
                |m: &mut EnvelopeNodeConfig| { &mut m.decay },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "sustain",
                |m: &EnvelopeNodeConfig| { &m.sustain },
                |m: &mut EnvelopeNodeConfig| { &mut m.sustain },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "release",
                |m: &EnvelopeNodeConfig| { &m.release },
                |m: &mut EnvelopeNodeConfig| { &mut m.release },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EnvelopeNodeConfig>(
                "EnvelopeNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EnvelopeNodeConfig {
        static instance: ::protobuf::rt::LazyV2<EnvelopeNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EnvelopeNodeConfig::new)
    }
}

impl ::protobuf::Clear for EnvelopeNodeConfig {
    fn clear(&mut self) {
        self.attack = 0.;
        self.decay = 0.;
        self.sustain = 0.;
        self.release = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnvelopeNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnvelopeNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ClockNodeConfig {
    // message fields
    pub speed: f64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClockNodeConfig {
    fn default() -> &'a ClockNodeConfig {
        <ClockNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl ClockNodeConfig {
    pub fn new() -> ClockNodeConfig {
        ::std::default::Default::default()
    }

    // double speed = 1;


    pub fn get_speed(&self) -> f64 {
        self.speed
    }
    pub fn clear_speed(&mut self) {
        self.speed = 0.;
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: f64) {
        self.speed = v;
    }
}

impl ::protobuf::Message for ClockNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.speed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.speed != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.speed != 0. {
            os.write_double(1, self.speed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClockNodeConfig {
        ClockNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "speed",
                |m: &ClockNodeConfig| { &m.speed },
                |m: &mut ClockNodeConfig| { &mut m.speed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClockNodeConfig>(
                "ClockNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClockNodeConfig {
        static instance: ::protobuf::rt::LazyV2<ClockNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClockNodeConfig::new)
    }
}

impl ::protobuf::Clear for ClockNodeConfig {
    fn clear(&mut self) {
        self.speed = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClockNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClockNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FixtureNodeConfig {
    // message fields
    pub fixture_id: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FixtureNodeConfig {
    fn default() -> &'a FixtureNodeConfig {
        <FixtureNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl FixtureNodeConfig {
    pub fn new() -> FixtureNodeConfig {
        ::std::default::Default::default()
    }

    // uint32 fixture_id = 1;


    pub fn get_fixture_id(&self) -> u32 {
        self.fixture_id
    }
    pub fn clear_fixture_id(&mut self) {
        self.fixture_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_fixture_id(&mut self, v: u32) {
        self.fixture_id = v;
    }
}

impl ::protobuf::Message for FixtureNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fixture_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fixture_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fixture_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fixture_id != 0 {
            os.write_uint32(1, self.fixture_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FixtureNodeConfig {
        FixtureNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "fixture_id",
                |m: &FixtureNodeConfig| { &m.fixture_id },
                |m: &mut FixtureNodeConfig| { &mut m.fixture_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FixtureNodeConfig>(
                "FixtureNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FixtureNodeConfig {
        static instance: ::protobuf::rt::LazyV2<FixtureNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FixtureNodeConfig::new)
    }
}

impl ::protobuf::Clear for FixtureNodeConfig {
    fn clear(&mut self) {
        self.fixture_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FixtureNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FixtureNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SequencerNodeConfig {
    // message fields
    pub sequence_id: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SequencerNodeConfig {
    fn default() -> &'a SequencerNodeConfig {
        <SequencerNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl SequencerNodeConfig {
    pub fn new() -> SequencerNodeConfig {
        ::std::default::Default::default()
    }

    // uint32 sequence_id = 1;


    pub fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u32) {
        self.sequence_id = v;
    }
}

impl ::protobuf::Message for SequencerNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sequence_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.sequence_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.sequence_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.sequence_id != 0 {
            os.write_uint32(1, self.sequence_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SequencerNodeConfig {
        SequencerNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sequence_id",
                |m: &SequencerNodeConfig| { &m.sequence_id },
                |m: &mut SequencerNodeConfig| { &mut m.sequence_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SequencerNodeConfig>(
                "SequencerNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SequencerNodeConfig {
        static instance: ::protobuf::rt::LazyV2<SequencerNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SequencerNodeConfig::new)
    }
}

impl ::protobuf::Clear for SequencerNodeConfig {
    fn clear(&mut self) {
        self.sequence_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SequencerNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SequencerNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InputNodeConfig {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InputNodeConfig {
    fn default() -> &'a InputNodeConfig {
        <InputNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl InputNodeConfig {
    pub fn new() -> InputNodeConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InputNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InputNodeConfig {
        InputNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InputNodeConfig>(
                "InputNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InputNodeConfig {
        static instance: ::protobuf::rt::LazyV2<InputNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InputNodeConfig::new)
    }
}

impl ::protobuf::Clear for InputNodeConfig {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InputNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct IldaFileNodeConfig {
    // message fields
    pub file: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IldaFileNodeConfig {
    fn default() -> &'a IldaFileNodeConfig {
        <IldaFileNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl IldaFileNodeConfig {
    pub fn new() -> IldaFileNodeConfig {
        ::std::default::Default::default()
    }

    // string file = 1;


    pub fn get_file(&self) -> &str {
        &self.file
    }
    pub fn clear_file(&mut self) {
        self.file.clear();
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: ::std::string::String) {
        self.file = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file(&mut self) -> &mut ::std::string::String {
        &mut self.file
    }

    // Take field
    pub fn take_file(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file, ::std::string::String::new())
    }
}

impl ::protobuf::Message for IldaFileNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.file.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.file.is_empty() {
            os.write_string(1, &self.file)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IldaFileNodeConfig {
        IldaFileNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file",
                |m: &IldaFileNodeConfig| { &m.file },
                |m: &mut IldaFileNodeConfig| { &mut m.file },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IldaFileNodeConfig>(
                "IldaFileNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IldaFileNodeConfig {
        static instance: ::protobuf::rt::LazyV2<IldaFileNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IldaFileNodeConfig::new)
    }
}

impl ::protobuf::Clear for IldaFileNodeConfig {
    fn clear(&mut self) {
        self.file.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IldaFileNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IldaFileNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LaserNodeConfig {
    // message fields
    pub device_id: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LaserNodeConfig {
    fn default() -> &'a LaserNodeConfig {
        <LaserNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl LaserNodeConfig {
    pub fn new() -> LaserNodeConfig {
        ::std::default::Default::default()
    }

    // string device_id = 1;


    pub fn get_device_id(&self) -> &str {
        &self.device_id
    }
    pub fn clear_device_id(&mut self) {
        self.device_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: ::std::string::String) {
        self.device_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_id(&mut self) -> &mut ::std::string::String {
        &mut self.device_id
    }

    // Take field
    pub fn take_device_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LaserNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.device_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.device_id.is_empty() {
            os.write_string(1, &self.device_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LaserNodeConfig {
        LaserNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_id",
                |m: &LaserNodeConfig| { &m.device_id },
                |m: &mut LaserNodeConfig| { &mut m.device_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LaserNodeConfig>(
                "LaserNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LaserNodeConfig {
        static instance: ::protobuf::rt::LazyV2<LaserNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LaserNodeConfig::new)
    }
}

impl ::protobuf::Clear for LaserNodeConfig {
    fn clear(&mut self) {
        self.device_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LaserNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LaserNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GamepadNodeConfig {
    // message fields
    pub device_id: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GamepadNodeConfig {
    fn default() -> &'a GamepadNodeConfig {
        <GamepadNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl GamepadNodeConfig {
    pub fn new() -> GamepadNodeConfig {
        ::std::default::Default::default()
    }

    // string device_id = 1;


    pub fn get_device_id(&self) -> &str {
        &self.device_id
    }
    pub fn clear_device_id(&mut self) {
        self.device_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: ::std::string::String) {
        self.device_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_id(&mut self) -> &mut ::std::string::String {
        &mut self.device_id
    }

    // Take field
    pub fn take_device_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GamepadNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.device_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.device_id.is_empty() {
            os.write_string(1, &self.device_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GamepadNodeConfig {
        GamepadNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_id",
                |m: &GamepadNodeConfig| { &m.device_id },
                |m: &mut GamepadNodeConfig| { &mut m.device_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GamepadNodeConfig>(
                "GamepadNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GamepadNodeConfig {
        static instance: ::protobuf::rt::LazyV2<GamepadNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GamepadNodeConfig::new)
    }
}

impl ::protobuf::Clear for GamepadNodeConfig {
    fn clear(&mut self) {
        self.device_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GamepadNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GamepadNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PixelPatternNodeConfig {
    // message fields
    pub pattern: PixelPatternNodeConfig_Pattern,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PixelPatternNodeConfig {
    fn default() -> &'a PixelPatternNodeConfig {
        <PixelPatternNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl PixelPatternNodeConfig {
    pub fn new() -> PixelPatternNodeConfig {
        ::std::default::Default::default()
    }

    // .mizer.PixelPatternNodeConfig.Pattern pattern = 1;


    pub fn get_pattern(&self) -> PixelPatternNodeConfig_Pattern {
        self.pattern
    }
    pub fn clear_pattern(&mut self) {
        self.pattern = PixelPatternNodeConfig_Pattern::RgbIterate;
    }

    // Param is passed by value, moved
    pub fn set_pattern(&mut self, v: PixelPatternNodeConfig_Pattern) {
        self.pattern = v;
    }
}

impl ::protobuf::Message for PixelPatternNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.pattern, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.pattern != PixelPatternNodeConfig_Pattern::RgbIterate {
            my_size += ::protobuf::rt::enum_size(1, self.pattern);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.pattern != PixelPatternNodeConfig_Pattern::RgbIterate {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.pattern))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PixelPatternNodeConfig {
        PixelPatternNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PixelPatternNodeConfig_Pattern>>(
                "pattern",
                |m: &PixelPatternNodeConfig| { &m.pattern },
                |m: &mut PixelPatternNodeConfig| { &mut m.pattern },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PixelPatternNodeConfig>(
                "PixelPatternNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PixelPatternNodeConfig {
        static instance: ::protobuf::rt::LazyV2<PixelPatternNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PixelPatternNodeConfig::new)
    }
}

impl ::protobuf::Clear for PixelPatternNodeConfig {
    fn clear(&mut self) {
        self.pattern = PixelPatternNodeConfig_Pattern::RgbIterate;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PixelPatternNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PixelPatternNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum PixelPatternNodeConfig_Pattern {
    RgbIterate = 0,
    RgbSnake = 1,
}

impl ::protobuf::ProtobufEnum for PixelPatternNodeConfig_Pattern {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PixelPatternNodeConfig_Pattern> {
        match value {
            0 => ::std::option::Option::Some(PixelPatternNodeConfig_Pattern::RgbIterate),
            1 => ::std::option::Option::Some(PixelPatternNodeConfig_Pattern::RgbSnake),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PixelPatternNodeConfig_Pattern] = &[
            PixelPatternNodeConfig_Pattern::RgbIterate,
            PixelPatternNodeConfig_Pattern::RgbSnake,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PixelPatternNodeConfig_Pattern>("PixelPatternNodeConfig.Pattern", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PixelPatternNodeConfig_Pattern {
}

impl ::std::default::Default for PixelPatternNodeConfig_Pattern {
    fn default() -> Self {
        PixelPatternNodeConfig_Pattern::RgbIterate
    }
}

impl ::protobuf::reflect::ProtobufValue for PixelPatternNodeConfig_Pattern {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PixelDmxNodeConfig {
    // message fields
    pub width: u64,
    pub height: u64,
    pub start_universe: u32,
    pub output: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PixelDmxNodeConfig {
    fn default() -> &'a PixelDmxNodeConfig {
        <PixelDmxNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl PixelDmxNodeConfig {
    pub fn new() -> PixelDmxNodeConfig {
        ::std::default::Default::default()
    }

    // uint64 width = 1;


    pub fn get_width(&self) -> u64 {
        self.width
    }
    pub fn clear_width(&mut self) {
        self.width = 0;
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u64) {
        self.width = v;
    }

    // uint64 height = 2;


    pub fn get_height(&self) -> u64 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u64) {
        self.height = v;
    }

    // uint32 start_universe = 3;


    pub fn get_start_universe(&self) -> u32 {
        self.start_universe
    }
    pub fn clear_start_universe(&mut self) {
        self.start_universe = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_universe(&mut self, v: u32) {
        self.start_universe = v;
    }

    // string output = 4;


    pub fn get_output(&self) -> &str {
        &self.output
    }
    pub fn clear_output(&mut self) {
        self.output.clear();
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: ::std::string::String) {
        self.output = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output(&mut self) -> &mut ::std::string::String {
        &mut self.output
    }

    // Take field
    pub fn take_output(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.output, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PixelDmxNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.width = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.height = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_universe = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.output)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.width != 0 {
            my_size += ::protobuf::rt::value_size(1, self.width, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.start_universe != 0 {
            my_size += ::protobuf::rt::value_size(3, self.start_universe, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.output.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.output);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.width != 0 {
            os.write_uint64(1, self.width)?;
        }
        if self.height != 0 {
            os.write_uint64(2, self.height)?;
        }
        if self.start_universe != 0 {
            os.write_uint32(3, self.start_universe)?;
        }
        if !self.output.is_empty() {
            os.write_string(4, &self.output)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PixelDmxNodeConfig {
        PixelDmxNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "width",
                |m: &PixelDmxNodeConfig| { &m.width },
                |m: &mut PixelDmxNodeConfig| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "height",
                |m: &PixelDmxNodeConfig| { &m.height },
                |m: &mut PixelDmxNodeConfig| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "start_universe",
                |m: &PixelDmxNodeConfig| { &m.start_universe },
                |m: &mut PixelDmxNodeConfig| { &mut m.start_universe },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "output",
                |m: &PixelDmxNodeConfig| { &m.output },
                |m: &mut PixelDmxNodeConfig| { &mut m.output },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PixelDmxNodeConfig>(
                "PixelDmxNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PixelDmxNodeConfig {
        static instance: ::protobuf::rt::LazyV2<PixelDmxNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PixelDmxNodeConfig::new)
    }
}

impl ::protobuf::Clear for PixelDmxNodeConfig {
    fn clear(&mut self) {
        self.width = 0;
        self.height = 0;
        self.start_universe = 0;
        self.output.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PixelDmxNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PixelDmxNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DmxOutputNodeConfig {
    // message fields
    pub universe: u32,
    pub channel: u32,
    // message oneof groups
    pub _output: ::std::option::Option<DmxOutputNodeConfig_oneof__output>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DmxOutputNodeConfig {
    fn default() -> &'a DmxOutputNodeConfig {
        <DmxOutputNodeConfig as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum DmxOutputNodeConfig_oneof__output {
    output(::std::string::String),
}

impl DmxOutputNodeConfig {
    pub fn new() -> DmxOutputNodeConfig {
        ::std::default::Default::default()
    }

    // string output = 1;


    pub fn get_output(&self) -> &str {
        match self._output {
            ::std::option::Option::Some(DmxOutputNodeConfig_oneof__output::output(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_output(&mut self) {
        self._output = ::std::option::Option::None;
    }

    pub fn has_output(&self) -> bool {
        match self._output {
            ::std::option::Option::Some(DmxOutputNodeConfig_oneof__output::output(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: ::std::string::String) {
        self._output = ::std::option::Option::Some(DmxOutputNodeConfig_oneof__output::output(v))
    }

    // Mutable pointer to the field.
    pub fn mut_output(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(DmxOutputNodeConfig_oneof__output::output(_)) = self._output {
        } else {
            self._output = ::std::option::Option::Some(DmxOutputNodeConfig_oneof__output::output(::std::string::String::new()));
        }
        match self._output {
            ::std::option::Option::Some(DmxOutputNodeConfig_oneof__output::output(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_output(&mut self) -> ::std::string::String {
        if self.has_output() {
            match self._output.take() {
                ::std::option::Option::Some(DmxOutputNodeConfig_oneof__output::output(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // uint32 universe = 2;


    pub fn get_universe(&self) -> u32 {
        self.universe
    }
    pub fn clear_universe(&mut self) {
        self.universe = 0;
    }

    // Param is passed by value, moved
    pub fn set_universe(&mut self, v: u32) {
        self.universe = v;
    }

    // uint32 channel = 3;


    pub fn get_channel(&self) -> u32 {
        self.channel
    }
    pub fn clear_channel(&mut self) {
        self.channel = 0;
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = v;
    }
}

impl ::protobuf::Message for DmxOutputNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._output = ::std::option::Option::Some(DmxOutputNodeConfig_oneof__output::output(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.universe = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.universe != 0 {
            my_size += ::protobuf::rt::value_size(2, self.universe, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.channel != 0 {
            my_size += ::protobuf::rt::value_size(3, self.channel, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self._output {
            match v {
                &DmxOutputNodeConfig_oneof__output::output(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.universe != 0 {
            os.write_uint32(2, self.universe)?;
        }
        if self.channel != 0 {
            os.write_uint32(3, self.channel)?;
        }
        if let ::std::option::Option::Some(ref v) = self._output {
            match v {
                &DmxOutputNodeConfig_oneof__output::output(ref v) => {
                    os.write_string(1, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DmxOutputNodeConfig {
        DmxOutputNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "output",
                DmxOutputNodeConfig::has_output,
                DmxOutputNodeConfig::get_output,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "universe",
                |m: &DmxOutputNodeConfig| { &m.universe },
                |m: &mut DmxOutputNodeConfig| { &mut m.universe },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channel",
                |m: &DmxOutputNodeConfig| { &m.channel },
                |m: &mut DmxOutputNodeConfig| { &mut m.channel },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DmxOutputNodeConfig>(
                "DmxOutputNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DmxOutputNodeConfig {
        static instance: ::protobuf::rt::LazyV2<DmxOutputNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DmxOutputNodeConfig::new)
    }
}

impl ::protobuf::Clear for DmxOutputNodeConfig {
    fn clear(&mut self) {
        self._output = ::std::option::Option::None;
        self.universe = 0;
        self.channel = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DmxOutputNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DmxOutputNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MidiNodeConfig {
    // message fields
    pub device: ::std::string::String,
    // message oneof groups
    pub binding: ::std::option::Option<MidiNodeConfig_oneof_binding>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MidiNodeConfig {
    fn default() -> &'a MidiNodeConfig {
        <MidiNodeConfig as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum MidiNodeConfig_oneof_binding {
    noteBinding(MidiNodeConfig_NoteBinding),
    controlBinding(MidiNodeConfig_ControlBinding),
}

impl MidiNodeConfig {
    pub fn new() -> MidiNodeConfig {
        ::std::default::Default::default()
    }

    // string device = 1;


    pub fn get_device(&self) -> &str {
        &self.device
    }
    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        &mut self.device
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device, ::std::string::String::new())
    }

    // .mizer.MidiNodeConfig.NoteBinding noteBinding = 2;


    pub fn get_noteBinding(&self) -> &MidiNodeConfig_NoteBinding {
        match self.binding {
            ::std::option::Option::Some(MidiNodeConfig_oneof_binding::noteBinding(ref v)) => v,
            _ => <MidiNodeConfig_NoteBinding as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_noteBinding(&mut self) {
        self.binding = ::std::option::Option::None;
    }

    pub fn has_noteBinding(&self) -> bool {
        match self.binding {
            ::std::option::Option::Some(MidiNodeConfig_oneof_binding::noteBinding(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_noteBinding(&mut self, v: MidiNodeConfig_NoteBinding) {
        self.binding = ::std::option::Option::Some(MidiNodeConfig_oneof_binding::noteBinding(v))
    }

    // Mutable pointer to the field.
    pub fn mut_noteBinding(&mut self) -> &mut MidiNodeConfig_NoteBinding {
        if let ::std::option::Option::Some(MidiNodeConfig_oneof_binding::noteBinding(_)) = self.binding {
        } else {
            self.binding = ::std::option::Option::Some(MidiNodeConfig_oneof_binding::noteBinding(MidiNodeConfig_NoteBinding::new()));
        }
        match self.binding {
            ::std::option::Option::Some(MidiNodeConfig_oneof_binding::noteBinding(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_noteBinding(&mut self) -> MidiNodeConfig_NoteBinding {
        if self.has_noteBinding() {
            match self.binding.take() {
                ::std::option::Option::Some(MidiNodeConfig_oneof_binding::noteBinding(v)) => v,
                _ => panic!(),
            }
        } else {
            MidiNodeConfig_NoteBinding::new()
        }
    }

    // .mizer.MidiNodeConfig.ControlBinding controlBinding = 3;


    pub fn get_controlBinding(&self) -> &MidiNodeConfig_ControlBinding {
        match self.binding {
            ::std::option::Option::Some(MidiNodeConfig_oneof_binding::controlBinding(ref v)) => v,
            _ => <MidiNodeConfig_ControlBinding as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_controlBinding(&mut self) {
        self.binding = ::std::option::Option::None;
    }

    pub fn has_controlBinding(&self) -> bool {
        match self.binding {
            ::std::option::Option::Some(MidiNodeConfig_oneof_binding::controlBinding(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_controlBinding(&mut self, v: MidiNodeConfig_ControlBinding) {
        self.binding = ::std::option::Option::Some(MidiNodeConfig_oneof_binding::controlBinding(v))
    }

    // Mutable pointer to the field.
    pub fn mut_controlBinding(&mut self) -> &mut MidiNodeConfig_ControlBinding {
        if let ::std::option::Option::Some(MidiNodeConfig_oneof_binding::controlBinding(_)) = self.binding {
        } else {
            self.binding = ::std::option::Option::Some(MidiNodeConfig_oneof_binding::controlBinding(MidiNodeConfig_ControlBinding::new()));
        }
        match self.binding {
            ::std::option::Option::Some(MidiNodeConfig_oneof_binding::controlBinding(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_controlBinding(&mut self) -> MidiNodeConfig_ControlBinding {
        if self.has_controlBinding() {
            match self.binding.take() {
                ::std::option::Option::Some(MidiNodeConfig_oneof_binding::controlBinding(v)) => v,
                _ => panic!(),
            }
        } else {
            MidiNodeConfig_ControlBinding::new()
        }
    }
}

impl ::protobuf::Message for MidiNodeConfig {
    fn is_initialized(&self) -> bool {
        if let Some(MidiNodeConfig_oneof_binding::noteBinding(ref v)) = self.binding {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MidiNodeConfig_oneof_binding::controlBinding(ref v)) = self.binding {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.binding = ::std::option::Option::Some(MidiNodeConfig_oneof_binding::noteBinding(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.binding = ::std::option::Option::Some(MidiNodeConfig_oneof_binding::controlBinding(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.device.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.device);
        }
        if let ::std::option::Option::Some(ref v) = self.binding {
            match v {
                &MidiNodeConfig_oneof_binding::noteBinding(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MidiNodeConfig_oneof_binding::controlBinding(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.device.is_empty() {
            os.write_string(1, &self.device)?;
        }
        if let ::std::option::Option::Some(ref v) = self.binding {
            match v {
                &MidiNodeConfig_oneof_binding::noteBinding(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MidiNodeConfig_oneof_binding::controlBinding(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MidiNodeConfig {
        MidiNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device",
                |m: &MidiNodeConfig| { &m.device },
                |m: &mut MidiNodeConfig| { &mut m.device },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MidiNodeConfig_NoteBinding>(
                "noteBinding",
                MidiNodeConfig::has_noteBinding,
                MidiNodeConfig::get_noteBinding,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MidiNodeConfig_ControlBinding>(
                "controlBinding",
                MidiNodeConfig::has_controlBinding,
                MidiNodeConfig::get_controlBinding,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MidiNodeConfig>(
                "MidiNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MidiNodeConfig {
        static instance: ::protobuf::rt::LazyV2<MidiNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MidiNodeConfig::new)
    }
}

impl ::protobuf::Clear for MidiNodeConfig {
    fn clear(&mut self) {
        self.device.clear();
        self.binding = ::std::option::Option::None;
        self.binding = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MidiNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MidiNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MidiNodeConfig_NoteBinding {
    // message fields
    pub channel: u32,
    pub field_type: MidiNodeConfig_NoteBinding_MidiType,
    pub port: u32,
    pub rangeFrom: u32,
    pub rangeTo: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MidiNodeConfig_NoteBinding {
    fn default() -> &'a MidiNodeConfig_NoteBinding {
        <MidiNodeConfig_NoteBinding as ::protobuf::Message>::default_instance()
    }
}

impl MidiNodeConfig_NoteBinding {
    pub fn new() -> MidiNodeConfig_NoteBinding {
        ::std::default::Default::default()
    }

    // uint32 channel = 1;


    pub fn get_channel(&self) -> u32 {
        self.channel
    }
    pub fn clear_channel(&mut self) {
        self.channel = 0;
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = v;
    }

    // .mizer.MidiNodeConfig.NoteBinding.MidiType type = 2;


    pub fn get_field_type(&self) -> MidiNodeConfig_NoteBinding_MidiType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = MidiNodeConfig_NoteBinding_MidiType::CC;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: MidiNodeConfig_NoteBinding_MidiType) {
        self.field_type = v;
    }

    // uint32 port = 3;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }

    // uint32 rangeFrom = 4;


    pub fn get_rangeFrom(&self) -> u32 {
        self.rangeFrom
    }
    pub fn clear_rangeFrom(&mut self) {
        self.rangeFrom = 0;
    }

    // Param is passed by value, moved
    pub fn set_rangeFrom(&mut self, v: u32) {
        self.rangeFrom = v;
    }

    // uint32 rangeTo = 5;


    pub fn get_rangeTo(&self) -> u32 {
        self.rangeTo
    }
    pub fn clear_rangeTo(&mut self) {
        self.rangeTo = 0;
    }

    // Param is passed by value, moved
    pub fn set_rangeTo(&mut self, v: u32) {
        self.rangeTo = v;
    }
}

impl ::protobuf::Message for MidiNodeConfig_NoteBinding {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rangeFrom = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rangeTo = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.channel != 0 {
            my_size += ::protobuf::rt::value_size(1, self.channel, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.field_type != MidiNodeConfig_NoteBinding_MidiType::CC {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(3, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rangeFrom != 0 {
            my_size += ::protobuf::rt::value_size(4, self.rangeFrom, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rangeTo != 0 {
            my_size += ::protobuf::rt::value_size(5, self.rangeTo, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.channel != 0 {
            os.write_uint32(1, self.channel)?;
        }
        if self.field_type != MidiNodeConfig_NoteBinding_MidiType::CC {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.port != 0 {
            os.write_uint32(3, self.port)?;
        }
        if self.rangeFrom != 0 {
            os.write_uint32(4, self.rangeFrom)?;
        }
        if self.rangeTo != 0 {
            os.write_uint32(5, self.rangeTo)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MidiNodeConfig_NoteBinding {
        MidiNodeConfig_NoteBinding::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channel",
                |m: &MidiNodeConfig_NoteBinding| { &m.channel },
                |m: &mut MidiNodeConfig_NoteBinding| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MidiNodeConfig_NoteBinding_MidiType>>(
                "type",
                |m: &MidiNodeConfig_NoteBinding| { &m.field_type },
                |m: &mut MidiNodeConfig_NoteBinding| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port",
                |m: &MidiNodeConfig_NoteBinding| { &m.port },
                |m: &mut MidiNodeConfig_NoteBinding| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rangeFrom",
                |m: &MidiNodeConfig_NoteBinding| { &m.rangeFrom },
                |m: &mut MidiNodeConfig_NoteBinding| { &mut m.rangeFrom },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rangeTo",
                |m: &MidiNodeConfig_NoteBinding| { &m.rangeTo },
                |m: &mut MidiNodeConfig_NoteBinding| { &mut m.rangeTo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MidiNodeConfig_NoteBinding>(
                "MidiNodeConfig.NoteBinding",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MidiNodeConfig_NoteBinding {
        static instance: ::protobuf::rt::LazyV2<MidiNodeConfig_NoteBinding> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MidiNodeConfig_NoteBinding::new)
    }
}

impl ::protobuf::Clear for MidiNodeConfig_NoteBinding {
    fn clear(&mut self) {
        self.channel = 0;
        self.field_type = MidiNodeConfig_NoteBinding_MidiType::CC;
        self.port = 0;
        self.rangeFrom = 0;
        self.rangeTo = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MidiNodeConfig_NoteBinding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MidiNodeConfig_NoteBinding {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum MidiNodeConfig_NoteBinding_MidiType {
    CC = 0,
    Note = 1,
}

impl ::protobuf::ProtobufEnum for MidiNodeConfig_NoteBinding_MidiType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MidiNodeConfig_NoteBinding_MidiType> {
        match value {
            0 => ::std::option::Option::Some(MidiNodeConfig_NoteBinding_MidiType::CC),
            1 => ::std::option::Option::Some(MidiNodeConfig_NoteBinding_MidiType::Note),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MidiNodeConfig_NoteBinding_MidiType] = &[
            MidiNodeConfig_NoteBinding_MidiType::CC,
            MidiNodeConfig_NoteBinding_MidiType::Note,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<MidiNodeConfig_NoteBinding_MidiType>("MidiNodeConfig.NoteBinding.MidiType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for MidiNodeConfig_NoteBinding_MidiType {
}

impl ::std::default::Default for MidiNodeConfig_NoteBinding_MidiType {
    fn default() -> Self {
        MidiNodeConfig_NoteBinding_MidiType::CC
    }
}

impl ::protobuf::reflect::ProtobufValue for MidiNodeConfig_NoteBinding_MidiType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MidiNodeConfig_ControlBinding {
    // message fields
    pub page: ::std::string::String,
    pub control: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MidiNodeConfig_ControlBinding {
    fn default() -> &'a MidiNodeConfig_ControlBinding {
        <MidiNodeConfig_ControlBinding as ::protobuf::Message>::default_instance()
    }
}

impl MidiNodeConfig_ControlBinding {
    pub fn new() -> MidiNodeConfig_ControlBinding {
        ::std::default::Default::default()
    }

    // string page = 1;


    pub fn get_page(&self) -> &str {
        &self.page
    }
    pub fn clear_page(&mut self) {
        self.page.clear();
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: ::std::string::String) {
        self.page = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page(&mut self) -> &mut ::std::string::String {
        &mut self.page
    }

    // Take field
    pub fn take_page(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page, ::std::string::String::new())
    }

    // string control = 2;


    pub fn get_control(&self) -> &str {
        &self.control
    }
    pub fn clear_control(&mut self) {
        self.control.clear();
    }

    // Param is passed by value, moved
    pub fn set_control(&mut self, v: ::std::string::String) {
        self.control = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_control(&mut self) -> &mut ::std::string::String {
        &mut self.control
    }

    // Take field
    pub fn take_control(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.control, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MidiNodeConfig_ControlBinding {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.control)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.page.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.page);
        }
        if !self.control.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.control);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.page.is_empty() {
            os.write_string(1, &self.page)?;
        }
        if !self.control.is_empty() {
            os.write_string(2, &self.control)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MidiNodeConfig_ControlBinding {
        MidiNodeConfig_ControlBinding::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page",
                |m: &MidiNodeConfig_ControlBinding| { &m.page },
                |m: &mut MidiNodeConfig_ControlBinding| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "control",
                |m: &MidiNodeConfig_ControlBinding| { &m.control },
                |m: &mut MidiNodeConfig_ControlBinding| { &mut m.control },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MidiNodeConfig_ControlBinding>(
                "MidiNodeConfig.ControlBinding",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MidiNodeConfig_ControlBinding {
        static instance: ::protobuf::rt::LazyV2<MidiNodeConfig_ControlBinding> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MidiNodeConfig_ControlBinding::new)
    }
}

impl ::protobuf::Clear for MidiNodeConfig_ControlBinding {
    fn clear(&mut self) {
        self.page.clear();
        self.control.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MidiNodeConfig_ControlBinding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MidiNodeConfig_ControlBinding {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct OpcOutputNodeConfig {
    // message fields
    pub host: ::std::string::String,
    pub port: u32,
    pub width: u64,
    pub height: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpcOutputNodeConfig {
    fn default() -> &'a OpcOutputNodeConfig {
        <OpcOutputNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl OpcOutputNodeConfig {
    pub fn new() -> OpcOutputNodeConfig {
        ::std::default::Default::default()
    }

    // string host = 1;


    pub fn get_host(&self) -> &str {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }

    // uint64 width = 3;


    pub fn get_width(&self) -> u64 {
        self.width
    }
    pub fn clear_width(&mut self) {
        self.width = 0;
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u64) {
        self.width = v;
    }

    // uint64 height = 4;


    pub fn get_height(&self) -> u64 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u64) {
        self.height = v;
    }
}

impl ::protobuf::Message for OpcOutputNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.width = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::value_size(3, self.width, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.host.is_empty() {
            os.write_string(1, &self.host)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if self.width != 0 {
            os.write_uint64(3, self.width)?;
        }
        if self.height != 0 {
            os.write_uint64(4, self.height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpcOutputNodeConfig {
        OpcOutputNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host",
                |m: &OpcOutputNodeConfig| { &m.host },
                |m: &mut OpcOutputNodeConfig| { &mut m.host },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port",
                |m: &OpcOutputNodeConfig| { &m.port },
                |m: &mut OpcOutputNodeConfig| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "width",
                |m: &OpcOutputNodeConfig| { &m.width },
                |m: &mut OpcOutputNodeConfig| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "height",
                |m: &OpcOutputNodeConfig| { &m.height },
                |m: &mut OpcOutputNodeConfig| { &mut m.height },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpcOutputNodeConfig>(
                "OpcOutputNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpcOutputNodeConfig {
        static instance: ::protobuf::rt::LazyV2<OpcOutputNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpcOutputNodeConfig::new)
    }
}

impl ::protobuf::Clear for OpcOutputNodeConfig {
    fn clear(&mut self) {
        self.host.clear();
        self.port = 0;
        self.width = 0;
        self.height = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpcOutputNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpcOutputNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct OscNodeConfig {
    // message fields
    pub host: ::std::string::String,
    pub port: u32,
    pub path: ::std::string::String,
    pub argumentType: OscNodeConfig_ArgumentType,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OscNodeConfig {
    fn default() -> &'a OscNodeConfig {
        <OscNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl OscNodeConfig {
    pub fn new() -> OscNodeConfig {
        ::std::default::Default::default()
    }

    // string host = 1;


    pub fn get_host(&self) -> &str {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }

    // string path = 3;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // .mizer.OscNodeConfig.ArgumentType argumentType = 4;


    pub fn get_argumentType(&self) -> OscNodeConfig_ArgumentType {
        self.argumentType
    }
    pub fn clear_argumentType(&mut self) {
        self.argumentType = OscNodeConfig_ArgumentType::Int;
    }

    // Param is passed by value, moved
    pub fn set_argumentType(&mut self, v: OscNodeConfig_ArgumentType) {
        self.argumentType = v;
    }
}

impl ::protobuf::Message for OscNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.argumentType, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.path);
        }
        if self.argumentType != OscNodeConfig_ArgumentType::Int {
            my_size += ::protobuf::rt::enum_size(4, self.argumentType);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.host.is_empty() {
            os.write_string(1, &self.host)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if !self.path.is_empty() {
            os.write_string(3, &self.path)?;
        }
        if self.argumentType != OscNodeConfig_ArgumentType::Int {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.argumentType))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OscNodeConfig {
        OscNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host",
                |m: &OscNodeConfig| { &m.host },
                |m: &mut OscNodeConfig| { &mut m.host },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port",
                |m: &OscNodeConfig| { &m.port },
                |m: &mut OscNodeConfig| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &OscNodeConfig| { &m.path },
                |m: &mut OscNodeConfig| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OscNodeConfig_ArgumentType>>(
                "argumentType",
                |m: &OscNodeConfig| { &m.argumentType },
                |m: &mut OscNodeConfig| { &mut m.argumentType },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OscNodeConfig>(
                "OscNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OscNodeConfig {
        static instance: ::protobuf::rt::LazyV2<OscNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OscNodeConfig::new)
    }
}

impl ::protobuf::Clear for OscNodeConfig {
    fn clear(&mut self) {
        self.host.clear();
        self.port = 0;
        self.path.clear();
        self.argumentType = OscNodeConfig_ArgumentType::Int;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OscNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OscNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum OscNodeConfig_ArgumentType {
    Int = 0,
    Float = 1,
    Long = 2,
    Double = 3,
    Bool = 4,
    Color = 5,
}

impl ::protobuf::ProtobufEnum for OscNodeConfig_ArgumentType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OscNodeConfig_ArgumentType> {
        match value {
            0 => ::std::option::Option::Some(OscNodeConfig_ArgumentType::Int),
            1 => ::std::option::Option::Some(OscNodeConfig_ArgumentType::Float),
            2 => ::std::option::Option::Some(OscNodeConfig_ArgumentType::Long),
            3 => ::std::option::Option::Some(OscNodeConfig_ArgumentType::Double),
            4 => ::std::option::Option::Some(OscNodeConfig_ArgumentType::Bool),
            5 => ::std::option::Option::Some(OscNodeConfig_ArgumentType::Color),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OscNodeConfig_ArgumentType] = &[
            OscNodeConfig_ArgumentType::Int,
            OscNodeConfig_ArgumentType::Float,
            OscNodeConfig_ArgumentType::Long,
            OscNodeConfig_ArgumentType::Double,
            OscNodeConfig_ArgumentType::Bool,
            OscNodeConfig_ArgumentType::Color,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OscNodeConfig_ArgumentType>("OscNodeConfig.ArgumentType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OscNodeConfig_ArgumentType {
}

impl ::std::default::Default for OscNodeConfig_ArgumentType {
    fn default() -> Self {
        OscNodeConfig_ArgumentType::Int
    }
}

impl ::protobuf::reflect::ProtobufValue for OscNodeConfig_ArgumentType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VideoColorBalanceNodeConfig {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoColorBalanceNodeConfig {
    fn default() -> &'a VideoColorBalanceNodeConfig {
        <VideoColorBalanceNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl VideoColorBalanceNodeConfig {
    pub fn new() -> VideoColorBalanceNodeConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VideoColorBalanceNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoColorBalanceNodeConfig {
        VideoColorBalanceNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VideoColorBalanceNodeConfig>(
                "VideoColorBalanceNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoColorBalanceNodeConfig {
        static instance: ::protobuf::rt::LazyV2<VideoColorBalanceNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VideoColorBalanceNodeConfig::new)
    }
}

impl ::protobuf::Clear for VideoColorBalanceNodeConfig {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoColorBalanceNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoColorBalanceNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VideoEffectNodeConfig {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoEffectNodeConfig {
    fn default() -> &'a VideoEffectNodeConfig {
        <VideoEffectNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl VideoEffectNodeConfig {
    pub fn new() -> VideoEffectNodeConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VideoEffectNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoEffectNodeConfig {
        VideoEffectNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VideoEffectNodeConfig>(
                "VideoEffectNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoEffectNodeConfig {
        static instance: ::protobuf::rt::LazyV2<VideoEffectNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VideoEffectNodeConfig::new)
    }
}

impl ::protobuf::Clear for VideoEffectNodeConfig {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoEffectNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoEffectNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VideoFileNodeConfig {
    // message fields
    pub file: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoFileNodeConfig {
    fn default() -> &'a VideoFileNodeConfig {
        <VideoFileNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl VideoFileNodeConfig {
    pub fn new() -> VideoFileNodeConfig {
        ::std::default::Default::default()
    }

    // string file = 1;


    pub fn get_file(&self) -> &str {
        &self.file
    }
    pub fn clear_file(&mut self) {
        self.file.clear();
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: ::std::string::String) {
        self.file = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file(&mut self) -> &mut ::std::string::String {
        &mut self.file
    }

    // Take field
    pub fn take_file(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VideoFileNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.file.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.file.is_empty() {
            os.write_string(1, &self.file)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoFileNodeConfig {
        VideoFileNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file",
                |m: &VideoFileNodeConfig| { &m.file },
                |m: &mut VideoFileNodeConfig| { &mut m.file },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VideoFileNodeConfig>(
                "VideoFileNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoFileNodeConfig {
        static instance: ::protobuf::rt::LazyV2<VideoFileNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VideoFileNodeConfig::new)
    }
}

impl ::protobuf::Clear for VideoFileNodeConfig {
    fn clear(&mut self) {
        self.file.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoFileNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoFileNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VideoOutputNodeConfig {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoOutputNodeConfig {
    fn default() -> &'a VideoOutputNodeConfig {
        <VideoOutputNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl VideoOutputNodeConfig {
    pub fn new() -> VideoOutputNodeConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VideoOutputNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoOutputNodeConfig {
        VideoOutputNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VideoOutputNodeConfig>(
                "VideoOutputNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoOutputNodeConfig {
        static instance: ::protobuf::rt::LazyV2<VideoOutputNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VideoOutputNodeConfig::new)
    }
}

impl ::protobuf::Clear for VideoOutputNodeConfig {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoOutputNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoOutputNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VideoTransformNodeConfig {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoTransformNodeConfig {
    fn default() -> &'a VideoTransformNodeConfig {
        <VideoTransformNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl VideoTransformNodeConfig {
    pub fn new() -> VideoTransformNodeConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VideoTransformNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoTransformNodeConfig {
        VideoTransformNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VideoTransformNodeConfig>(
                "VideoTransformNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoTransformNodeConfig {
        static instance: ::protobuf::rt::LazyV2<VideoTransformNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VideoTransformNodeConfig::new)
    }
}

impl ::protobuf::Clear for VideoTransformNodeConfig {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoTransformNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoTransformNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SelectNodeConfig {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SelectNodeConfig {
    fn default() -> &'a SelectNodeConfig {
        <SelectNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl SelectNodeConfig {
    pub fn new() -> SelectNodeConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SelectNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SelectNodeConfig {
        SelectNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SelectNodeConfig>(
                "SelectNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SelectNodeConfig {
        static instance: ::protobuf::rt::LazyV2<SelectNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SelectNodeConfig::new)
    }
}

impl ::protobuf::Clear for SelectNodeConfig {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SelectNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MergeNodeConfig {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MergeNodeConfig {
    fn default() -> &'a MergeNodeConfig {
        <MergeNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl MergeNodeConfig {
    pub fn new() -> MergeNodeConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MergeNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MergeNodeConfig {
        MergeNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MergeNodeConfig>(
                "MergeNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MergeNodeConfig {
        static instance: ::protobuf::rt::LazyV2<MergeNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MergeNodeConfig::new)
    }
}

impl ::protobuf::Clear for MergeNodeConfig {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MergeNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MergeNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ThresholdNodeConfig {
    // message fields
    pub threshold: f64,
    pub active_value: f64,
    pub inactive_value: f64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThresholdNodeConfig {
    fn default() -> &'a ThresholdNodeConfig {
        <ThresholdNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl ThresholdNodeConfig {
    pub fn new() -> ThresholdNodeConfig {
        ::std::default::Default::default()
    }

    // double threshold = 1;


    pub fn get_threshold(&self) -> f64 {
        self.threshold
    }
    pub fn clear_threshold(&mut self) {
        self.threshold = 0.;
    }

    // Param is passed by value, moved
    pub fn set_threshold(&mut self, v: f64) {
        self.threshold = v;
    }

    // double active_value = 2;


    pub fn get_active_value(&self) -> f64 {
        self.active_value
    }
    pub fn clear_active_value(&mut self) {
        self.active_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_active_value(&mut self, v: f64) {
        self.active_value = v;
    }

    // double inactive_value = 3;


    pub fn get_inactive_value(&self) -> f64 {
        self.inactive_value
    }
    pub fn clear_inactive_value(&mut self) {
        self.inactive_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_inactive_value(&mut self, v: f64) {
        self.inactive_value = v;
    }
}

impl ::protobuf::Message for ThresholdNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.threshold = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.active_value = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.inactive_value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.threshold != 0. {
            my_size += 9;
        }
        if self.active_value != 0. {
            my_size += 9;
        }
        if self.inactive_value != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.threshold != 0. {
            os.write_double(1, self.threshold)?;
        }
        if self.active_value != 0. {
            os.write_double(2, self.active_value)?;
        }
        if self.inactive_value != 0. {
            os.write_double(3, self.inactive_value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThresholdNodeConfig {
        ThresholdNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "threshold",
                |m: &ThresholdNodeConfig| { &m.threshold },
                |m: &mut ThresholdNodeConfig| { &mut m.threshold },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "active_value",
                |m: &ThresholdNodeConfig| { &m.active_value },
                |m: &mut ThresholdNodeConfig| { &mut m.active_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "inactive_value",
                |m: &ThresholdNodeConfig| { &m.inactive_value },
                |m: &mut ThresholdNodeConfig| { &mut m.inactive_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ThresholdNodeConfig>(
                "ThresholdNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ThresholdNodeConfig {
        static instance: ::protobuf::rt::LazyV2<ThresholdNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ThresholdNodeConfig::new)
    }
}

impl ::protobuf::Clear for ThresholdNodeConfig {
    fn clear(&mut self) {
        self.threshold = 0.;
        self.active_value = 0.;
        self.inactive_value = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThresholdNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThresholdNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ColorRgbNodeConfig {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ColorRgbNodeConfig {
    fn default() -> &'a ColorRgbNodeConfig {
        <ColorRgbNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl ColorRgbNodeConfig {
    pub fn new() -> ColorRgbNodeConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ColorRgbNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ColorRgbNodeConfig {
        ColorRgbNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ColorRgbNodeConfig>(
                "ColorRgbNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ColorRgbNodeConfig {
        static instance: ::protobuf::rt::LazyV2<ColorRgbNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ColorRgbNodeConfig::new)
    }
}

impl ::protobuf::Clear for ColorRgbNodeConfig {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ColorRgbNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColorRgbNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ColorHsvNodeConfig {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ColorHsvNodeConfig {
    fn default() -> &'a ColorHsvNodeConfig {
        <ColorHsvNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl ColorHsvNodeConfig {
    pub fn new() -> ColorHsvNodeConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ColorHsvNodeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ColorHsvNodeConfig {
        ColorHsvNodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ColorHsvNodeConfig>(
                "ColorHsvNodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ColorHsvNodeConfig {
        static instance: ::protobuf::rt::LazyV2<ColorHsvNodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ColorHsvNodeConfig::new)
    }
}

impl ::protobuf::Clear for ColorHsvNodeConfig {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ColorHsvNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColorHsvNodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NodePosition {
    // message fields
    pub x: f64,
    pub y: f64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodePosition {
    fn default() -> &'a NodePosition {
        <NodePosition as ::protobuf::Message>::default_instance()
    }
}

impl NodePosition {
    pub fn new() -> NodePosition {
        ::std::default::Default::default()
    }

    // double x = 1;


    pub fn get_x(&self) -> f64 {
        self.x
    }
    pub fn clear_x(&mut self) {
        self.x = 0.;
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f64) {
        self.x = v;
    }

    // double y = 2;


    pub fn get_y(&self) -> f64 {
        self.y
    }
    pub fn clear_y(&mut self) {
        self.y = 0.;
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f64) {
        self.y = v;
    }
}

impl ::protobuf::Message for NodePosition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.x = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.y = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x != 0. {
            my_size += 9;
        }
        if self.y != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x != 0. {
            os.write_double(1, self.x)?;
        }
        if self.y != 0. {
            os.write_double(2, self.y)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodePosition {
        NodePosition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "x",
                |m: &NodePosition| { &m.x },
                |m: &mut NodePosition| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "y",
                |m: &NodePosition| { &m.y },
                |m: &mut NodePosition| { &mut m.y },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodePosition>(
                "NodePosition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodePosition {
        static instance: ::protobuf::rt::LazyV2<NodePosition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodePosition::new)
    }
}

impl ::protobuf::Clear for NodePosition {
    fn clear(&mut self) {
        self.x = 0.;
        self.y = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodePosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodePosition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NodeDesigner {
    // message fields
    pub position: ::protobuf::SingularPtrField<NodePosition>,
    pub scale: f64,
    pub hidden: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeDesigner {
    fn default() -> &'a NodeDesigner {
        <NodeDesigner as ::protobuf::Message>::default_instance()
    }
}

impl NodeDesigner {
    pub fn new() -> NodeDesigner {
        ::std::default::Default::default()
    }

    // .mizer.NodePosition position = 1;


    pub fn get_position(&self) -> &NodePosition {
        self.position.as_ref().unwrap_or_else(|| <NodePosition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: NodePosition) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut NodePosition {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> NodePosition {
        self.position.take().unwrap_or_else(|| NodePosition::new())
    }

    // double scale = 2;


    pub fn get_scale(&self) -> f64 {
        self.scale
    }
    pub fn clear_scale(&mut self) {
        self.scale = 0.;
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f64) {
        self.scale = v;
    }

    // bool hidden = 3;


    pub fn get_hidden(&self) -> bool {
        self.hidden
    }
    pub fn clear_hidden(&mut self) {
        self.hidden = false;
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: bool) {
        self.hidden = v;
    }
}

impl ::protobuf::Message for NodeDesigner {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.scale = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hidden = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.scale != 0. {
            my_size += 9;
        }
        if self.hidden != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.scale != 0. {
            os.write_double(2, self.scale)?;
        }
        if self.hidden != false {
            os.write_bool(3, self.hidden)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeDesigner {
        NodeDesigner::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodePosition>>(
                "position",
                |m: &NodeDesigner| { &m.position },
                |m: &mut NodeDesigner| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "scale",
                |m: &NodeDesigner| { &m.scale },
                |m: &mut NodeDesigner| { &mut m.scale },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hidden",
                |m: &NodeDesigner| { &m.hidden },
                |m: &mut NodeDesigner| { &mut m.hidden },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeDesigner>(
                "NodeDesigner",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeDesigner {
        static instance: ::protobuf::rt::LazyV2<NodeDesigner> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeDesigner::new)
    }
}

impl ::protobuf::Clear for NodeDesigner {
    fn clear(&mut self) {
        self.position.clear();
        self.scale = 0.;
        self.hidden = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeDesigner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeDesigner {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Port {
    // message fields
    pub name: ::std::string::String,
    pub protocol: ChannelProtocol,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Port {
    fn default() -> &'a Port {
        <Port as ::protobuf::Message>::default_instance()
    }
}

impl Port {
    pub fn new() -> Port {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .mizer.ChannelProtocol protocol = 2;


    pub fn get_protocol(&self) -> ChannelProtocol {
        self.protocol
    }
    pub fn clear_protocol(&mut self) {
        self.protocol = ChannelProtocol::SINGLE;
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ChannelProtocol) {
        self.protocol = v;
    }
}

impl ::protobuf::Message for Port {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.protocol, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.protocol != ChannelProtocol::SINGLE {
            my_size += ::protobuf::rt::enum_size(2, self.protocol);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.protocol != ChannelProtocol::SINGLE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.protocol))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Port {
        Port::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Port| { &m.name },
                |m: &mut Port| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ChannelProtocol>>(
                "protocol",
                |m: &Port| { &m.protocol },
                |m: &mut Port| { &mut m.protocol },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Port>(
                "Port",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Port {
        static instance: ::protobuf::rt::LazyV2<Port> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Port::new)
    }
}

impl ::protobuf::Clear for Port {
    fn clear(&mut self) {
        self.name.clear();
        self.protocol = ChannelProtocol::SINGLE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Port {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Port {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ChannelProtocol {
    SINGLE = 0,
    MULTI = 1,
    COLOR = 9,
    TEXTURE = 2,
    VECTOR = 3,
    LASER = 4,
    POLY = 5,
    DATA = 6,
    MATERIAL = 7,
    GST = 8,
}

impl ::protobuf::ProtobufEnum for ChannelProtocol {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChannelProtocol> {
        match value {
            0 => ::std::option::Option::Some(ChannelProtocol::SINGLE),
            1 => ::std::option::Option::Some(ChannelProtocol::MULTI),
            9 => ::std::option::Option::Some(ChannelProtocol::COLOR),
            2 => ::std::option::Option::Some(ChannelProtocol::TEXTURE),
            3 => ::std::option::Option::Some(ChannelProtocol::VECTOR),
            4 => ::std::option::Option::Some(ChannelProtocol::LASER),
            5 => ::std::option::Option::Some(ChannelProtocol::POLY),
            6 => ::std::option::Option::Some(ChannelProtocol::DATA),
            7 => ::std::option::Option::Some(ChannelProtocol::MATERIAL),
            8 => ::std::option::Option::Some(ChannelProtocol::GST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ChannelProtocol] = &[
            ChannelProtocol::SINGLE,
            ChannelProtocol::MULTI,
            ChannelProtocol::COLOR,
            ChannelProtocol::TEXTURE,
            ChannelProtocol::VECTOR,
            ChannelProtocol::LASER,
            ChannelProtocol::POLY,
            ChannelProtocol::DATA,
            ChannelProtocol::MATERIAL,
            ChannelProtocol::GST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ChannelProtocol>("ChannelProtocol", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ChannelProtocol {
}

impl ::std::default::Default for ChannelProtocol {
    fn default() -> Self {
        ChannelProtocol::SINGLE
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelProtocol {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bnodes.proto\x12\x05mizer\"k\n\x0eAddNodeRequest\x12(\n\x04type\x18\
    \x01\x20\x01(\x0e2\x14.mizer.Node.NodeTypeR\x04type\x12/\n\x08position\
    \x18\x02\x20\x01(\x0b2\x13.mizer.NodePositionR\x08position\"\x0e\n\x0cNo\
    desRequest\"L\n\x0cWriteControl\x12\x12\n\x04path\x18\x01\x20\x01(\tR\
    \x04path\x12\x12\n\x04port\x18\x02\x20\x01(\tR\x04port\x12\x14\n\x05valu\
    e\x18\x03\x20\x01(\x01R\x05value\"\x0f\n\rWriteResponse\"X\n\x17UpdateNo\
    deConfigRequest\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x12)\n\x06\
    config\x18\x02\x20\x01(\x0b2\x11.mizer.NodeConfigR\x06config\"\x1a\n\x18\
    UpdateNodeConfigResponse\"V\n\x0fMoveNodeRequest\x12\x12\n\x04path\x18\
    \x01\x20\x01(\tR\x04path\x12/\n\x08position\x18\x02\x20\x01(\x0b2\x13.mi\
    zer.NodePositionR\x08position\"\x12\n\x10MoveNodeResponse\"V\n\x0fShowNo\
    deRequest\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x12/\n\x08positi\
    on\x18\x02\x20\x01(\x0b2\x13.mizer.NodePositionR\x08position\"\x12\n\x10\
    ShowNodeResponse\"'\n\x11DeleteNodeRequest\x12\x12\n\x04path\x18\x01\x20\
    \x01(\tR\x04path\"\x14\n\x12DeleteNodeResponse\"]\n\x05Nodes\x12!\n\x05n\
    odes\x18\x01\x20\x03(\x0b2\x0b.mizer.NodeR\x05nodes\x121\n\x08channels\
    \x18\x02\x20\x03(\x0b2\x15.mizer.NodeConnectionR\x08channels\"\xde\x01\n\
    \x0eNodeConnection\x12\x1e\n\ntargetNode\x18\x01\x20\x01(\tR\ntargetNode\
    \x12+\n\ntargetPort\x18\x02\x20\x01(\x0b2\x0b.mizer.PortR\ntargetPort\
    \x12\x1e\n\nsourceNode\x18\x03\x20\x01(\tR\nsourceNode\x12+\n\nsourcePor\
    t\x18\x04\x20\x01(\x0b2\x0b.mizer.PortR\nsourcePort\x122\n\x08protocol\
    \x18\x05\x20\x01(\x0e2\x16.mizer.ChannelProtocolR\x08protocol\"\xe0\x06\
    \n\x04Node\x12(\n\x04type\x18\x01\x20\x01(\x0e2\x14.mizer.Node.NodeTypeR\
    \x04type\x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12#\n\x06inputs\
    \x18\x03\x20\x03(\x0b2\x0b.mizer.PortR\x06inputs\x12%\n\x07outputs\x18\
    \x04\x20\x03(\x0b2\x0b.mizer.PortR\x07outputs\x12/\n\x08designer\x18\x05\
    \x20\x01(\x0b2\x13.mizer.NodeDesignerR\x08designer\x125\n\x07preview\x18\
    \x06\x20\x01(\x0e2\x1b.mizer.Node.NodePreviewTypeR\x07preview\x12)\n\x06\
    config\x18\x07\x20\x01(\x0b2\x11.mizer.NodeConfigR\x06config\"\xe7\x03\n\
    \x08NodeType\x12\t\n\x05Fader\x10\0\x12\n\n\x06Button\x10\x01\x12\x0e\n\
    \nOscillator\x10\x02\x12\t\n\x05Clock\x10\x03\x12\n\n\x06Script\x10\x04\
    \x12\x0c\n\x08Envelope\x10\x05\x12\x0c\n\x08Sequence\x10\x06\x12\n\n\x06\
    Select\x10\x07\x12\t\n\x05Merge\x10\x08\x12\r\n\tThreshold\x10\t\x12\r\n\
    \tDmxOutput\x10\n\x12\x0c\n\x08OscInput\x10\x0b\x12\r\n\tOscOutput\x10\
    \x0c\x12\r\n\tMidiInput\x10\r\x12\x0e\n\nMidiOutput\x10\x0e\x12\r\n\tSeq\
    uencer\x10\x0f\x12\x0b\n\x07Fixture\x10\x10\x12\x0e\n\nProgrammer\x10\
    \x11\x12\t\n\x05Group\x10\x12\x12\n\n\x06Preset\x10\x13\x12\r\n\tVideoFi\
    le\x10\x14\x12\x0f\n\x0bVideoOutput\x10\x15\x12\x0f\n\x0bVideoEffect\x10\
    \x16\x12\x15\n\x11VideoColorBalance\x10\x17\x12\x12\n\x0eVideoTransform\
    \x10\x18\x12\x0e\n\nPixelToDmx\x10\x1e\x12\x10\n\x0cPixelPattern\x10\x1f\
    \x12\r\n\tOpcOutput\x10\x20\x12\t\n\x05Laser\x10(\x12\x0c\n\x08IldaFile\
    \x10)\x12\x0b\n\x07Gamepad\x10-\x12\x0c\n\x08ColorRgb\x102\x12\x0c\n\x08\
    ColorHsv\x103\"Q\n\x0fNodePreviewType\x12\x0b\n\x07History\x10\0\x12\x0c\
    \n\x08Waveform\x10\x01\x12\x0c\n\x08Multiple\x10\x02\x12\x0b\n\x07Textur\
    e\x10\x03\x12\x08\n\x04None\x10\x04\"\x9a\x12\n\nNodeConfig\x12I\n\x10os\
    cillatorConfig\x18\n\x20\x01(\x0b2\x1b.mizer.OscillatorNodeConfigH\0R\
    \x10oscillatorConfig\x12F\n\x0fscriptingConfig\x18\x0b\x20\x01(\x0b2\x1a\
    .mizer.ScriptingNodeConfigH\0R\x0fscriptingConfig\x12C\n\x0esequenceConf\
    ig\x18\x0c\x20\x01(\x0b2\x19.mizer.SequenceNodeConfigH\0R\x0esequenceCon\
    fig\x12:\n\x0bclockConfig\x18\r\x20\x01(\x0b2\x16.mizer.ClockNodeConfigH\
    \0R\x0bclockConfig\x12@\n\rfixtureConfig\x18\x0e\x20\x01(\x0b2\x18.mizer\
    .FixtureNodeConfigH\0R\rfixtureConfig\x12<\n\x0cbuttonConfig\x18\x0f\x20\
    \x01(\x0b2\x16.mizer.InputNodeConfigH\0R\x0cbuttonConfig\x12:\n\x0bfader\
    Config\x18\x10\x20\x01(\x0b2\x16.mizer.InputNodeConfigH\0R\x0bfaderConfi\
    g\x12C\n\x0eildaFileConfig\x18\x11\x20\x01(\x0b2\x19.mizer.IldaFileNodeC\
    onfigH\0R\x0eildaFileConfig\x12:\n\x0blaserConfig\x18\x12\x20\x01(\x0b2\
    \x16.mizer.LaserNodeConfigH\0R\x0blaserConfig\x12O\n\x12pixelPatternConf\
    ig\x18\x13\x20\x01(\x0b2\x1d.mizer.PixelPatternNodeConfigH\0R\x12pixelPa\
    tternConfig\x12C\n\x0epixelDmxConfig\x18\x14\x20\x01(\x0b2\x19.mizer.Pix\
    elDmxNodeConfigH\0R\x0epixelDmxConfig\x12F\n\x0fdmxOutputConfig\x18\x15\
    \x20\x01(\x0b2\x1a.mizer.DmxOutputNodeConfigH\0R\x0fdmxOutputConfig\x12A\
    \n\x0fmidiInputConfig\x18\x16\x20\x01(\x0b2\x15.mizer.MidiNodeConfigH\0R\
    \x0fmidiInputConfig\x12C\n\x10midiOutputConfig\x18\x17\x20\x01(\x0b2\x15\
    .mizer.MidiNodeConfigH\0R\x10midiOutputConfig\x12F\n\x0fopcOutputConfig\
    \x18\x18\x20\x01(\x0b2\x1a.mizer.OpcOutputNodeConfigH\0R\x0fopcOutputCon\
    fig\x12>\n\x0eoscInputConfig\x18\x19\x20\x01(\x0b2\x14.mizer.OscNodeConf\
    igH\0R\x0eoscInputConfig\x12@\n\x0foscOutputConfig\x18\x1a\x20\x01(\x0b2\
    \x14.mizer.OscNodeConfigH\0R\x0foscOutputConfig\x12^\n\x17videoColorBala\
    nceConfig\x18\x1b\x20\x01(\x0b2\".mizer.VideoColorBalanceNodeConfigH\0R\
    \x17videoColorBalanceConfig\x12L\n\x11videoEffectConfig\x18\x1c\x20\x01(\
    \x0b2\x1c.mizer.VideoEffectNodeConfigH\0R\x11videoEffectConfig\x12F\n\
    \x0fvideoFileConfig\x18\x1d\x20\x01(\x0b2\x1a.mizer.VideoFileNodeConfigH\
    \0R\x0fvideoFileConfig\x12L\n\x11videoOutputConfig\x18\x1e\x20\x01(\x0b2\
    \x1c.mizer.VideoOutputNodeConfigH\0R\x11videoOutputConfig\x12U\n\x14vide\
    oTransformConfig\x18\x1f\x20\x01(\x0b2\x1f.mizer.VideoTransformNodeConfi\
    gH\0R\x14videoTransformConfig\x12=\n\x0cselectConfig\x18\x20\x20\x01(\
    \x0b2\x17.mizer.SelectNodeConfigH\0R\x0cselectConfig\x12:\n\x0bmergeConf\
    ig\x18!\x20\x01(\x0b2\x16.mizer.MergeNodeConfigH\0R\x0bmergeConfig\x12C\
    \n\x0eenvelopeConfig\x18\"\x20\x01(\x0b2\x19.mizer.EnvelopeNodeConfigH\0\
    R\x0eenvelopeConfig\x12F\n\x0fsequencerConfig\x18#\x20\x01(\x0b2\x1a.miz\
    er.SequencerNodeConfigH\0R\x0fsequencerConfig\x12I\n\x10programmerConfig\
    \x18$\x20\x01(\x0b2\x1b.mizer.ProgrammerNodeConfigH\0R\x10programmerConf\
    ig\x12:\n\x0bgroupConfig\x18%\x20\x01(\x0b2\x16.mizer.GroupNodeConfigH\0\
    R\x0bgroupConfig\x12=\n\x0cpresetConfig\x18&\x20\x01(\x0b2\x17.mizer.Pre\
    setNodeConfigH\0R\x0cpresetConfig\x12C\n\x0ecolorRgbConfig\x18(\x20\x01(\
    \x0b2\x19.mizer.ColorRgbNodeConfigH\0R\x0ecolorRgbConfig\x12C\n\x0ecolor\
    HsvConfig\x18)\x20\x01(\x0b2\x19.mizer.ColorHsvNodeConfigH\0R\x0ecolorHs\
    vConfig\x12H\n\x11gamepadNodeConfig\x18*\x20\x01(\x0b2\x18.mizer.Gamepad\
    NodeConfigH\0R\x11gamepadNodeConfig\x12F\n\x0fthresholdConfig\x18+\x20\
    \x01(\x0b2\x1a.mizer.ThresholdNodeConfigH\0R\x0fthresholdConfigB\x06\n\
    \x04type\"\x81\x02\n\x14OscillatorNodeConfig\x12>\n\x04type\x18\x01\x20\
    \x01(\x0e2*.mizer.OscillatorNodeConfig.OscillatorTypeR\x04type\x12\x14\n\
    \x05ratio\x18\x02\x20\x01(\x01R\x05ratio\x12\x10\n\x03max\x18\x03\x20\
    \x01(\x01R\x03max\x12\x10\n\x03min\x18\x04\x20\x01(\x01R\x03min\x12\x16\
    \n\x06offset\x18\x05\x20\x01(\x01R\x06offset\x12\x18\n\x07reverse\x18\
    \x06\x20\x01(\x08R\x07reverse\"=\n\x0eOscillatorType\x12\n\n\x06Square\
    \x10\0\x12\x08\n\x04Sine\x10\x01\x12\x07\n\x03Saw\x10\x02\x12\x0c\n\x08T\
    riangle\x10\x03\"-\n\x13ScriptingNodeConfig\x12\x16\n\x06script\x18\x01\
    \x20\x01(\tR\x06script\"\xa0\x01\n\x12SequenceNodeConfig\x12<\n\x05steps\
    \x18\x01\x20\x03(\x0b2&.mizer.SequenceNodeConfig.SequenceStepR\x05steps\
    \x1aL\n\x0cSequenceStep\x12\x12\n\x04tick\x18\x01\x20\x01(\x01R\x04tick\
    \x12\x14\n\x05value\x18\x02\x20\x01(\x01R\x05value\x12\x12\n\x04hold\x18\
    \x03\x20\x01(\x08R\x04hold\"\x16\n\x14ProgrammerNodeConfig\"\x11\n\x0fGr\
    oupNodeConfig\"\x12\n\x10PresetNodeConfig\"v\n\x12EnvelopeNodeConfig\x12\
    \x16\n\x06attack\x18\x01\x20\x01(\x01R\x06attack\x12\x14\n\x05decay\x18\
    \x02\x20\x01(\x01R\x05decay\x12\x18\n\x07sustain\x18\x03\x20\x01(\x01R\
    \x07sustain\x12\x18\n\x07release\x18\x04\x20\x01(\x01R\x07release\"'\n\
    \x0fClockNodeConfig\x12\x14\n\x05speed\x18\x01\x20\x01(\x01R\x05speed\"2\
    \n\x11FixtureNodeConfig\x12\x1d\n\nfixture_id\x18\x01\x20\x01(\rR\tfixtu\
    reId\"6\n\x13SequencerNodeConfig\x12\x1f\n\x0bsequence_id\x18\x01\x20\
    \x01(\rR\nsequenceId\"\x11\n\x0fInputNodeConfig\"(\n\x12IldaFileNodeConf\
    ig\x12\x12\n\x04file\x18\x01\x20\x01(\tR\x04file\".\n\x0fLaserNodeConfig\
    \x12\x1b\n\tdevice_id\x18\x01\x20\x01(\tR\x08deviceId\"0\n\x11GamepadNod\
    eConfig\x12\x1b\n\tdevice_id\x18\x01\x20\x01(\tR\x08deviceId\"\x82\x01\n\
    \x16PixelPatternNodeConfig\x12?\n\x07pattern\x18\x01\x20\x01(\x0e2%.mize\
    r.PixelPatternNodeConfig.PatternR\x07pattern\"'\n\x07Pattern\x12\x0e\n\n\
    RgbIterate\x10\0\x12\x0c\n\x08RgbSnake\x10\x01\"\x81\x01\n\x12PixelDmxNo\
    deConfig\x12\x14\n\x05width\x18\x01\x20\x01(\x04R\x05width\x12\x16\n\x06\
    height\x18\x02\x20\x01(\x04R\x06height\x12%\n\x0estart_universe\x18\x03\
    \x20\x01(\rR\rstartUniverse\x12\x16\n\x06output\x18\x04\x20\x01(\tR\x06o\
    utput\"s\n\x13DmxOutputNodeConfig\x12\x1b\n\x06output\x18\x01\x20\x01(\t\
    H\0R\x06output\x88\x01\x01\x12\x1a\n\x08universe\x18\x02\x20\x01(\rR\x08\
    universe\x12\x18\n\x07channel\x18\x03\x20\x01(\rR\x07channelB\t\n\x07_ou\
    tput\"\xde\x03\n\x0eMidiNodeConfig\x12\x16\n\x06device\x18\x01\x20\x01(\
    \tR\x06device\x12E\n\x0bnoteBinding\x18\x02\x20\x01(\x0b2!.mizer.MidiNod\
    eConfig.NoteBindingH\0R\x0bnoteBinding\x12N\n\x0econtrolBinding\x18\x03\
    \x20\x01(\x0b2$.mizer.MidiNodeConfig.ControlBindingH\0R\x0econtrolBindin\
    g\x1a\xd1\x01\n\x0bNoteBinding\x12\x18\n\x07channel\x18\x01\x20\x01(\rR\
    \x07channel\x12>\n\x04type\x18\x02\x20\x01(\x0e2*.mizer.MidiNodeConfig.N\
    oteBinding.MidiTypeR\x04type\x12\x12\n\x04port\x18\x03\x20\x01(\rR\x04po\
    rt\x12\x1c\n\trangeFrom\x18\x04\x20\x01(\rR\trangeFrom\x12\x18\n\x07rang\
    eTo\x18\x05\x20\x01(\rR\x07rangeTo\"\x1c\n\x08MidiType\x12\x06\n\x02CC\
    \x10\0\x12\x08\n\x04Note\x10\x01\x1a>\n\x0eControlBinding\x12\x12\n\x04p\
    age\x18\x01\x20\x01(\tR\x04page\x12\x18\n\x07control\x18\x02\x20\x01(\tR\
    \x07controlB\t\n\x07binding\"k\n\x13OpcOutputNodeConfig\x12\x12\n\x04hos\
    t\x18\x01\x20\x01(\tR\x04host\x12\x12\n\x04port\x18\x02\x20\x01(\rR\x04p\
    ort\x12\x14\n\x05width\x18\x03\x20\x01(\x04R\x05width\x12\x16\n\x06heigh\
    t\x18\x04\x20\x01(\x04R\x06height\"\xe1\x01\n\rOscNodeConfig\x12\x12\n\
    \x04host\x18\x01\x20\x01(\tR\x04host\x12\x12\n\x04port\x18\x02\x20\x01(\
    \rR\x04port\x12\x12\n\x04path\x18\x03\x20\x01(\tR\x04path\x12E\n\x0cargu\
    mentType\x18\x04\x20\x01(\x0e2!.mizer.OscNodeConfig.ArgumentTypeR\x0carg\
    umentType\"M\n\x0cArgumentType\x12\x07\n\x03Int\x10\0\x12\t\n\x05Float\
    \x10\x01\x12\x08\n\x04Long\x10\x02\x12\n\n\x06Double\x10\x03\x12\x08\n\
    \x04Bool\x10\x04\x12\t\n\x05Color\x10\x05\"\x1d\n\x1bVideoColorBalanceNo\
    deConfig\"\x17\n\x15VideoEffectNodeConfig\")\n\x13VideoFileNodeConfig\
    \x12\x12\n\x04file\x18\x01\x20\x01(\tR\x04file\"\x17\n\x15VideoOutputNod\
    eConfig\"\x1a\n\x18VideoTransformNodeConfig\"\x12\n\x10SelectNodeConfig\
    \"\x11\n\x0fMergeNodeConfig\"}\n\x13ThresholdNodeConfig\x12\x1c\n\tthres\
    hold\x18\x01\x20\x01(\x01R\tthreshold\x12!\n\x0cactive_value\x18\x02\x20\
    \x01(\x01R\x0bactiveValue\x12%\n\x0einactive_value\x18\x03\x20\x01(\x01R\
    \rinactiveValue\"\x14\n\x12ColorRgbNodeConfig\"\x14\n\x12ColorHsvNodeCon\
    fig\"*\n\x0cNodePosition\x12\x0c\n\x01x\x18\x01\x20\x01(\x01R\x01x\x12\
    \x0c\n\x01y\x18\x02\x20\x01(\x01R\x01y\"m\n\x0cNodeDesigner\x12/\n\x08po\
    sition\x18\x01\x20\x01(\x0b2\x13.mizer.NodePositionR\x08position\x12\x14\
    \n\x05scale\x18\x02\x20\x01(\x01R\x05scale\x12\x16\n\x06hidden\x18\x03\
    \x20\x01(\x08R\x06hidden\"N\n\x04Port\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\x122\n\x08protocol\x18\x02\x20\x01(\x0e2\x16.mizer.ChannelPr\
    otocolR\x08protocol*\x82\x01\n\x0fChannelProtocol\x12\n\n\x06SINGLE\x10\
    \0\x12\t\n\x05MULTI\x10\x01\x12\t\n\x05COLOR\x10\t\x12\x0b\n\x07TEXTURE\
    \x10\x02\x12\n\n\x06VECTOR\x10\x03\x12\t\n\x05LASER\x10\x04\x12\x08\n\
    \x04POLY\x10\x05\x12\x08\n\x04DATA\x10\x06\x12\x0c\n\x08MATERIAL\x10\x07\
    \x12\x07\n\x03GST\x10\x082\x85\x04\n\x08NodesApi\x12/\n\x08GetNodes\x12\
    \x13.mizer.NodesRequest\x1a\x0c.mizer.Nodes\"\0\x12/\n\x07AddNode\x12\
    \x15.mizer.AddNodeRequest\x1a\x0b.mizer.Node\"\0\x129\n\x07AddLink\x12\
    \x15.mizer.NodeConnection\x1a\x15.mizer.NodeConnection\"\0\x12@\n\x11Wri\
    teControlValue\x12\x13.mizer.WriteControl\x1a\x14.mizer.WriteResponse\"\
    \0\x12W\n\x12UpdateNodeProperty\x12\x1e.mizer.UpdateNodeConfigRequest\
    \x1a\x1f.mizer.UpdateNodeConfigResponse\"\0\x12=\n\x08MoveNode\x12\x16.m\
    izer.MoveNodeRequest\x1a\x17.mizer.MoveNodeResponse\"\0\x12C\n\nDeleteNo\
    de\x12\x18.mizer.DeleteNodeRequest\x1a\x19.mizer.DeleteNodeResponse\"\0\
    \x12=\n\x08ShowNode\x12\x16.mizer.ShowNodeRequest\x1a\x17.mizer.ShowNode\
    Response\"\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
